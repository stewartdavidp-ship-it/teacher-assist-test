<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="gs-app-id" content="teacher-assist">
<meta name="version" content="1.0.0">
<title>Teach Assist</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>

  * { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #e4e4de; --surface: #eeeee8; --surface-alt: #e8e8e2;
    --text: #2a2a2a; --text-secondary: #4a4a4a; --text-muted: #777; --text-faint: #aaa;
    --border: #c8c8c0; --border-light: #d8d8d0;
    --input-bg: #f4f4ee; --input-border: #b8b8b0;
    --heading: #141414;
    --accent: #2563eb; --accent-hover: #1d4ed8; --accent-bg: #dce6f8; --accent-text: #1e52c0;
    --accent-soft: #c8d8f0;
    --success-bg: #d8f0e6; --success-text: #047a56; --success-border: #90dbb8;
    --warning-bg: #f0e8d0; --warning-text: #b86b00; --warning-border: #e0c878;
    --error-bg: #f0dada; --error-text: #c02020; --error-border: #e0a8a8;
    --danger: #dc2626; --danger-hover: #b91c1c; --danger-bg: #f0dada;
    --queue-item-bg: #e6eaf4;
    --cell-bg: #eeeee8; --cell-queued-bg: #dce6f8;
    --cell-printed-bg: #dcdcd6; --cell-printed-border: #c0c0b8; --cell-printed-text: #999;
    --shadow-sm: 0 1px 3px rgba(0,0,0,0.10);
    --shadow: 0 2px 8px rgba(0,0,0,0.10);
    --shadow-lg: 0 4px 16px rgba(0,0,0,0.12);
    --tab-inactive: #777; --tab-hover-bg: rgba(0,0,0,0.06);
    --card-hover: #e6e6e0;
    --preview-bg: #f6f6f0; --preview-border: #aaa; --preview-text: #000;
    --align-btn-bg: #e4e4de; --align-btn-active: #2563eb; --align-btn-active-text: #fff; --align-btn-text: #555;
    --saved-card-bg: #e8e8e2; --saved-card-border: #c8c8c0; --saved-card-hover: #e0e0da;
    --type-card-bg: #e8e8e2; --type-card-border: #c8c8c0; --type-card-active: #2563eb;
    --banner-plenty-bg: #d8f0e6; --banner-plenty-text: #047a56;
    --banner-low-bg: #f0e8d0; --banner-low-text: #b86b00;
    --banner-empty-bg: #f0dada; --banner-empty-text: #c02020;
    --toggle-bg: #b8b8b0; --toggle-active: #2563eb;
    --mono: 'JetBrains Mono', monospace;
  }

  [data-theme="dark"] {
    --bg: #0c0c10; --surface: #1e1e26; --surface-alt: #171720;
    --text: #eaeaee; --text-secondary: #c4c4cc; --text-muted: #9e9eac; --text-faint: #747484;
    --border: #52526a; --border-light: #44445a;
    --input-bg: #262630; --input-border: #5e5e72;
    --heading: #f8f8fc;
    --accent: #6c9eff; --accent-hover: #90b8ff; --accent-bg: #1c2c52; --accent-text: #90b8ff;
    --accent-soft: #283c68;
    --success-bg: #14302a; --success-text: #5cf0c0; --success-border: #208868;
    --warning-bg: #382e14; --warning-text: #ffd85c; --warning-border: #c07820;
    --error-bg: #3a1c1c; --error-text: #ffa0a0; --error-border: #dd3838;
    --danger: #ffa0a0; --danger-hover: #ffc8c8; --danger-bg: rgba(255,120,120,0.18);
    --queue-item-bg: #262630;
    --cell-bg: #2e2e3c; --cell-queued-bg: #1c2c52;
    --cell-printed-bg: #16161e; --cell-printed-border: #42425a; --cell-printed-text: #606078;
    --shadow-sm: 0 2px 4px rgba(0,0,0,0.5);
    --shadow: 0 3px 12px rgba(0,0,0,0.5);
    --shadow-lg: 0 8px 24px rgba(0,0,0,0.6);
    --tab-inactive: #9e9eac; --tab-hover-bg: rgba(255,255,255,0.08);
    --card-hover: #2c2c3a;
    --preview-bg: #fff; --preview-border: #888; --preview-text: #000;
    --align-btn-bg: #2e2e3c; --align-btn-active: #6c9eff; --align-btn-active-text: #fff; --align-btn-text: #c4c4cc;
    --saved-card-bg: #1e1e26; --saved-card-border: #52526a; --saved-card-hover: #32323e;
    --type-card-bg: #2e2e3c; --type-card-border: #52526a; --type-card-active: #6c9eff;
    --banner-plenty-bg: #14302a; --banner-plenty-text: #5cf0c0;
    --banner-low-bg: #382e14; --banner-low-text: #ffd85c;
    --banner-empty-bg: #3a1c1c; --banner-empty-text: #ffa0a0;
    --toggle-bg: #52526a; --toggle-active: #6c9eff;
  }

  body {
    font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg); color: var(--text);
    transition: background 0.3s, color 0.3s;
    min-height: 100vh;
  }

  /* ===== APP SHELL ===== */
  .app-shell { max-width: 1060px; margin: 0 auto; padding: 16px 20px; }

  .app-topbar {
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 0 16px; margin-bottom: 0;
  }
  .app-title {
    font-size: 20px; font-weight: 700; color: var(--heading);
    display: flex; align-items: center; gap: 8px; letter-spacing: -0.02em;
  }
  .app-title .version { font-size: 12px; font-weight: 500; color: var(--text-muted); font-family: var(--mono); }

  .topbar-actions { display: flex; align-items: center; gap: 12px; }

  /* Hamburger menu */
  .hamburger-menu { position: relative; }
  .hamburger-btn {
    background: none; border: 2px solid var(--border); border-radius: 8px;
    width: 40px; height: 40px; cursor: pointer; display: flex; align-items: center;
    justify-content: center; font-size: 20px; color: var(--text-secondary);
    transition: all 0.15s;
  }
  .hamburger-btn:hover { border-color: var(--accent); color: var(--accent); background: var(--accent-bg); }
  .hamburger-dropdown {
    display: none; position: absolute; top: 100%; right: 0; margin-top: 6px;
    background: var(--surface); border: 2px solid var(--border); border-radius: 10px;
    box-shadow: var(--shadow-lg); min-width: 220px; z-index: 200; overflow: hidden;
  }
  .hamburger-dropdown.visible { display: block; }
  .hamburger-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 16px; cursor: pointer; font-size: 14px; font-weight: 500;
    color: var(--text); transition: background 0.1s; border: none; background: none;
    width: 100%; font-family: inherit; text-align: left; gap: 10px;
  }
  .hamburger-item:hover { background: var(--accent-bg); color: var(--accent-text); }
  .hamburger-item + .hamburger-item { border-top: 1px solid var(--border-light); }
  .hamburger-item-label { display: flex; align-items: center; gap: 8px; }
  .hamburger-item .toggle-track {
    width: 38px; height: 22px; background: var(--toggle-bg); border-radius: 11px;
    position: relative; transition: background 0.3s; flex-shrink: 0;
  }
  .hamburger-item .toggle-track.active { background: var(--toggle-active); }
  .hamburger-item .toggle-track .toggle-thumb {
    width: 16px; height: 16px; background: #fff; border-radius: 50%;
    position: absolute; top: 3px; left: 3px; transition: transform 0.3s;
    display: flex; align-items: center; justify-content: center; font-size: 10px;
  }
  .hamburger-item .toggle-track.active .toggle-thumb { transform: translateX(16px); }

  /* ===== TAB BAR ===== */
  .tab-bar {
    display: flex; gap: 0; border-bottom: 2px solid var(--border);
    margin-bottom: 24px; position: relative;
  }
  .tab-btn {
    padding: 14px 22px; border: none; background: none;
    font-family: inherit; font-size: 16px; font-weight: 600;
    color: var(--tab-inactive); cursor: pointer;
    position: relative; transition: color 0.2s, background 0.2s;
    display: flex; align-items: center; gap: 8px;
    border-radius: 8px 8px 0 0;
  }
  .tab-btn:hover { color: var(--text); background: var(--tab-hover-bg); }
  .tab-btn.active { color: var(--accent); }
  .tab-btn.active::after {
    content: ''; position: absolute; bottom: -2px; left: 0; right: 0;
    height: 2px; background: var(--accent); border-radius: 1px 1px 0 0;
  }
  .tab-meta {
    font-size: 13px; font-weight: 600; color: var(--text-muted);
    max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .tab-btn.active .tab-meta { color: var(--accent-text); opacity: 0.7; }
  .tab-badge {
    background: var(--accent); color: #fff; font-size: 12px; font-weight: 700;
    min-width: 22px; height: 22px; border-radius: 11px;
    display: inline-flex; align-items: center; justify-content: center; padding: 0 6px;
  }
  .tab-badge.empty { background: var(--text-faint); }
  .tab-badge.pulse { animation: badgePulse 0.4s ease; }
  @keyframes badgePulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); }
    100% { transform: scale(1); }
  }

  /* ===== TAB PANELS ===== */
  .tab-panel { display: none; animation: fadeIn 0.25s ease; }
  .tab-panel.active { display: block; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }

  /* ===== SHEETS TAB ===== */
  .sheets-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  .sheets-col-header {
    font-size: 15px; font-weight: 700; color: var(--heading);
    text-transform: uppercase; letter-spacing: 0.06em;
    margin-bottom: 14px; display: flex; align-items: center; justify-content: space-between;
  }

  .sheet-cards { display: flex; flex-direction: column; gap: 10px; }
  .sheet-card {
    padding: 16px 18px; border: 2px solid var(--border); border-radius: 10px;
    background: var(--surface); cursor: pointer; transition: all 0.15s;
    display: flex; align-items: center; gap: 14px;
    box-shadow: var(--shadow);
  }
  .sheet-card:hover { background: var(--card-hover); border-color: var(--accent); }
  .sheet-card.active { border-color: var(--accent); background: var(--accent-bg); box-shadow: 0 0 0 2px var(--accent); }
  .sheet-card-info { flex: 1; min-width: 0; }
  .sheet-card-name {
    font-size: 17px; font-weight: 700; color: var(--heading);
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .sheet-card-detail { font-size: 14px; color: var(--text-secondary); margin-top: 4px; }
  .sheet-card-detail strong { color: var(--heading); font-weight: 700; }
  .sheet-card-progress {
    width: 48px; height: 48px; flex-shrink: 0;
    display: flex; align-items: center; justify-content: center;
    position: relative;
  }
  .sheet-card-progress svg { transform: rotate(-90deg); }
  .sheet-card-progress .progress-text {
    position: absolute; font-size: 12px; font-weight: 700; color: var(--heading);
    font-family: var(--mono);
  }
  .sheet-card-actions {
    display: flex; flex-direction: column; gap: 2px; flex-shrink: 0; opacity: 0;
    transition: opacity 0.15s;
  }
  .sheet-card:hover .sheet-card-actions { opacity: 1; }
  .sheet-card-action {
    background: none; border: none; font-size: 12px; cursor: pointer;
    padding: 3px 6px; border-radius: 4px; color: var(--text-muted);
    transition: all 0.15s;
  }
  .sheet-card-action:hover { background: var(--accent-bg); color: var(--accent); }
  .sheet-card-action.danger:hover { background: var(--danger-bg); color: var(--danger); }

  .new-sheet-card {
    padding: 16px; border: 3px dashed var(--border); border-radius: 10px;
    background: none; cursor: pointer; transition: all 0.15s;
    font-family: inherit; font-size: 15px; font-weight: 600;
    color: var(--accent-text); display: flex; align-items: center;
    justify-content: center; gap: 6px; width: 100%;
  }
  .new-sheet-card:hover { border-color: var(--accent); background: var(--accent-bg); }
  .new-text-card {
    padding: 14px; border: 3px dashed var(--border); border-radius: 10px;
    background: none; cursor: pointer; transition: all 0.15s;
    font-family: inherit; font-size: 14px; font-weight: 600;
    color: var(--accent-text); display: flex; align-items: center;
    justify-content: center; gap: 6px; width: 100%; margin-top: 8px;
  }
  .new-text-card:hover { border-color: var(--accent); background: var(--accent-bg); }

  .sheet-map-container {
    background: var(--surface); border-radius: 12px; padding: 18px;
    border: 2px solid var(--border); transition: background 0.3s;
    box-shadow: var(--shadow);
  }
  .sheet-map-header {
    font-size: 15px; font-weight: 700; color: var(--heading);
    margin-bottom: 4px; display: flex; align-items: center; justify-content: space-between;
  }
  .sheet-map-sub { font-size: 13px; color: var(--text-secondary); margin-bottom: 14px; }

  /* Shared grid + cell styles (used in sheets & print tabs) */
  .label-grid { display: grid; gap: 5px; }
  .label-cell {
    background: var(--cell-bg); border: 2px solid var(--border);
    border-radius: 5px; display: flex; flex-direction: column;
    align-items: center; justify-content: center; position: relative;
    overflow: hidden; font-size: 9px; transition: all 0.15s; min-height: 22px;
    box-shadow: var(--shadow-sm);
  }
  .label-cell.printed {
    background: var(--cell-printed-bg); border-color: var(--cell-printed-border);
    color: var(--cell-printed-text); opacity: 0.6; box-shadow: none;
    cursor: pointer;
  }
  .label-cell.printed:hover {
    opacity: 0.85; border-color: var(--accent); border-style: dashed;
  }
  .label-cell.queued {
    background: var(--cell-queued-bg); border: 2.5px dashed var(--accent);
  }
  .label-number { font-size: 9px; font-weight: 700; color: var(--text-secondary); font-family: var(--mono); }
  .printed-badge { font-size: 10px; color: var(--cell-printed-text); font-weight: 700; }
  .label-text { font-size: 9px; color: inherit; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 90%; }
  .empty-state { font-size: 8px; color: var(--text-muted); font-weight: 600; }
  [class*="cell-color-"] .label-number { color: inherit; opacity: 0.7; }
  [class*="cell-color-"] .label-text { color: inherit; }

  .remaining-bar {
    margin-top: 16px; padding: 14px 18px; border-radius: 8px;
    font-size: 16px; font-weight: 700; display: flex; align-items: center; gap: 10px;
    border: 2px solid transparent;
  }
  .remaining-bar.plenty { background: var(--banner-plenty-bg); color: var(--banner-plenty-text); border-color: var(--success-border); }
  .remaining-bar.low { background: var(--banner-low-bg); color: var(--banner-low-text); border-color: var(--warning-border); }
  .remaining-bar.empty { background: var(--banner-empty-bg); color: var(--banner-empty-text); border-color: var(--error-border); }
  .remaining-bar .count { font-size: 24px; font-family: var(--mono); }

  .legend { display: flex; gap: 16px; margin-top: 14px; }
  .legend-item { display: flex; align-items: center; gap: 6px; font-size: 13px; font-weight: 600; color: var(--text-secondary); }
  .legend-swatch { width: 18px; height: 12px; border-radius: 3px; border: 2px solid var(--border); }
  .legend-swatch.available { background: var(--cell-bg); }
  .legend-swatch.queued { background: var(--cell-queued-bg); border: 2px dashed var(--accent); }
  .legend-swatch.printed { background: var(--cell-printed-bg); border-color: var(--cell-printed-border); opacity: 0.55; }

  .no-sheet-selected {
    text-align: center; padding: 40px 20px; color: var(--text-muted); font-size: 15px;
  }
  .no-sheet-selected .icon { font-size: 36px; margin-bottom: 10px; display: block; }

  /* ===== LABELS TAB ===== */
  .labels-layout { display: grid; grid-template-columns: 3fr 2fr; gap: 20px; }

  .compose-panel { display: flex; flex-direction: column; gap: 12px; }
  .panel-section {
    background: var(--surface); border-radius: 12px; padding: 20px;
    border: 2px solid var(--border); transition: all 0.3s;
    box-shadow: var(--shadow);
  }
  .panel-section-title {
    font-size: 16px; font-weight: 700; color: var(--heading);
    margin-bottom: 12px; display: flex; align-items: center; gap: 6px;
  }

  /* Emoji picker */
  .emoji-picker-section { position: relative; margin-bottom: 4px; }
  .emoji-toggle-btn {
    padding: 5px 10px; border: 2px solid var(--border); border-radius: 8px;
    background: var(--surface-alt); color: var(--text); font-size: 14px;
    cursor: pointer; transition: all 0.15s; display: inline-flex; align-items: center; gap: 5px;
    font-family: inherit;
  }
  .emoji-toggle-btn:hover { border-color: var(--accent); }
  .emoji-toggle-btn.active { border-color: var(--accent); background: var(--accent-bg); }
  .emoji-panel {
    display: none; position: absolute; top: 100%; left: 0; margin-top: 4px;
    background: var(--surface); border: 2px solid var(--border); border-radius: 10px;
    box-shadow: var(--shadow-lg); padding: 8px; width: 290px; z-index: 100;
  }
  .emoji-panel.visible { display: block; }
  .emoji-panel-search {
    width: 100%; padding: 6px 10px; border: 2px solid var(--input-border); border-radius: 6px;
    background: var(--input-bg); color: var(--text); font-size: 12px; font-family: inherit;
    margin-bottom: 6px;
  }
  .emoji-panel-search:focus { outline: none; border-color: var(--accent); }
  .emoji-panel-search::placeholder { color: var(--text-faint); }
  .emoji-category { margin-bottom: 4px; }
  .emoji-category-label {
    font-size: 10px; font-weight: 700; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 0.5px; padding: 2px 4px;
  }
  .emoji-grid { display: flex; flex-wrap: wrap; gap: 2px; }
  .emoji-btn {
    width: 30px; height: 30px; border: none; border-radius: 6px;
    background: transparent; font-size: 17px; cursor: pointer;
    display: flex; align-items: center; justify-content: center; transition: background 0.1s;
  }
  .emoji-btn:hover { background: var(--accent-bg); }
  .emoji-scroll { max-height: 200px; overflow-y: auto; }

  /* Line inputs */
  .line-input-row { display: flex; align-items: center; gap: 4px; margin-bottom: 4px; }
  .line-input-row .line-num {
    font-size: 11px; font-weight: 700; color: var(--text-faint);
    width: 14px; text-align: center; flex-shrink: 0; font-family: var(--mono);
  }
  .line-input-row input[type="text"] {
    flex: 1; padding: 8px 10px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 15px; font-family: inherit; background: var(--input-bg); color: var(--text);
    transition: border-color 0.2s; min-width: 0;
  }
  .line-input-row input[type="text"]:focus { outline: none; border-color: var(--accent); }
  .line-input-row input[type="text"]::placeholder { color: var(--text-faint); font-size: 13px; }
  .line-align-btn {
    width: 28px; height: 28px; border: 2px solid var(--border); border-radius: 5px;
    background: var(--align-btn-bg); color: var(--align-btn-text); font-size: 13px;
    cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; flex-shrink: 0; padding: 0;
  }
  .line-align-btn:hover { border-color: var(--accent); }
  .line-align-btn.active { background: var(--align-btn-active); color: var(--align-btn-active-text); border-color: var(--align-btn-active); }
  .line-size-stepper { display: flex; align-items: center; gap: 0; flex-shrink: 0; margin-left: 2px; }
  .line-size-stepper .size-btn {
    width: 22px; height: 28px; border: 2px solid var(--border);
    background: var(--align-btn-bg); color: var(--align-btn-text);
    font-size: 14px; font-weight: 700; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; padding: 0; line-height: 1;
  }
  .line-size-stepper .size-btn:first-child { border-radius: 5px 0 0 5px; }
  .line-size-stepper .size-btn:last-child { border-radius: 0 5px 5px 0; }
  .line-size-stepper .size-btn:hover { border-color: var(--accent); color: var(--accent); }
  .line-size-stepper .size-val {
    width: 28px; height: 28px; border-top: 2px solid var(--border); border-bottom: 2px solid var(--border);
    background: var(--input-bg); color: var(--text); font-size: 11px; font-weight: 700;
    display: flex; align-items: center; justify-content: center; user-select: none;
    font-family: var(--mono);
  }
  .line-inputs-hint {
    font-size: 12px; color: var(--text-faint); margin-top: 2px; line-height: 1.4;
  }
  .line-inputs-hint code {
    background: var(--surface-alt); border: 1px solid var(--border); border-radius: 3px;
    padding: 0 3px; font-size: 11px; font-family: var(--mono);
  }

  /* Vertical alignment + quantity row */
  .controls-row { display: flex; align-items: center; gap: 14px; flex-wrap: wrap; }
  .control-group { display: flex; align-items: center; gap: 5px; }
  .control-group-label { font-size: 13px; font-weight: 600; color: var(--text-muted); white-space: nowrap; }
  .align-btn {
    min-width: 34px; height: 30px; padding: 0 6px; border: 2px solid var(--border);
    border-radius: 5px; background: var(--align-btn-bg); color: var(--align-btn-text);
    font-size: 13px; cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; white-space: nowrap; gap: 2px; font-family: inherit;
  }
  .align-btn:hover { border-color: var(--accent); }
  .align-btn.active { background: var(--align-btn-active); color: var(--align-btn-active-text); border-color: var(--align-btn-active); }

  .qty-input {
    width: 56px; padding: 5px 8px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 14px; font-weight: 600; text-align: center; font-family: var(--mono);
    background: var(--input-bg); color: var(--text);
  }
  .qty-input:focus { outline: none; border-color: var(--accent); }
  .qty-hint { font-size: 11px; color: var(--text-muted); }

  /* Preview */
  .preview-container {
    background: repeating-conic-gradient(#d8d8d2 0% 25%, #e4e4de 0% 50%) 50% / 12px 12px;
    border: 2px solid var(--border); border-radius: 8px;
    padding: 10px; display: flex; justify-content: center; align-items: center; min-height: 60px;
  }
  .preview-label {
    background: var(--preview-bg); border: 2px solid var(--preview-border); border-radius: 4px;
    padding: 6px 8px; font-family: Arial, sans-serif; color: var(--preview-text);
    overflow: hidden; word-break: break-word; display: flex; flex-direction: column; transition: all 0.15s;
  }
  .preview-label .preview-line { width: 100%; display: flex; white-space: nowrap; overflow: hidden; line-height: 1.3; }
  .preview-label .preview-line.align-left { justify-content: flex-start; }
  .preview-label .preview-line.align-center { justify-content: center; }
  .preview-label .preview-line.align-right { justify-content: flex-end; }
  .preview-label .preview-line.align-split { justify-content: space-between; }
  .preview-label .preview-line.fill-line { display: flex; align-items: flex-end; gap: 4px; }
  .preview-label .preview-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .preview-label .preview-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid currentColor; min-width: 12px; margin-bottom: 1px; }
  .preview-label.empty-preview { align-items: center; justify-content: center; color: #bbb; font-size: 12px; font-style: italic; }
  .preview-dimensions { text-align: center; font-size: 10px; color: var(--text-faint); margin-top: 4px; font-family: var(--mono); }

  /* Action buttons in compose */
  .compose-actions { display: flex; gap: 8px; margin-top: 4px; }
  .btn {
    padding: 10px 18px; border: 2px solid transparent; border-radius: 8px;
    font-family: inherit; font-size: 14px; font-weight: 600;
    cursor: pointer; transition: all 0.15s; display: inline-flex; align-items: center; gap: 6px;
  }
  .btn-primary { background: var(--accent); color: #fff; border-color: var(--accent); }
  .btn-primary:hover { background: var(--accent-hover); }
  .btn-primary:disabled { background: var(--text-faint); border-color: var(--text-faint); cursor: not-allowed; }
  .btn-secondary { background: var(--surface); color: var(--text); border-color: var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }
  .btn-danger { background: none; color: var(--danger); border-color: var(--danger); }
  .btn-danger:hover { background: var(--danger-bg); }
  .btn-sm { padding: 6px 12px; font-size: 12px; }
  .btn-full { width: 100%; justify-content: center; }

  /* Queue nudge bar on labels tab */
  .queue-nudge {
    margin-top: 8px; padding: 10px 14px; border-radius: 8px;
    background: var(--accent-bg); border: 2px solid var(--accent-soft);
    display: flex; align-items: center; justify-content: space-between;
    animation: fadeIn 0.25s ease;
  }
  .queue-nudge-text { font-size: 14px; font-weight: 600; color: var(--accent-text); }
  .queue-nudge-btn {
    padding: 6px 14px; border: 2px solid var(--accent); border-radius: 6px;
    background: var(--accent); color: #fff; font-family: inherit;
    font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.15s;
  }
  .queue-nudge-btn:hover { background: var(--accent-hover); }

  /* Editing indicator */
  .editing-indicator {
    padding: 8px 12px; border-radius: 8px; background: var(--warning-bg);
    border: 2px solid var(--warning-border); font-size: 13px; font-weight: 600;
    color: var(--warning-text); display: flex; align-items: center; justify-content: space-between;
  }
  .editing-indicator .cancel-edit {
    background: none; border: none; color: var(--warning-text); cursor: pointer;
    font-family: inherit; font-size: 12px; font-weight: 600; text-decoration: underline;
    padding: 2px 4px;
  }

  /* Status messages */
  .status-msg {
    padding: 9px 12px; border-radius: 8px; font-size: 13px; font-weight: 600;
    text-align: center; transition: all 0.3s; min-height: 0;
  }
  .status-msg.info { background: var(--accent-bg); color: var(--accent-text); }
  .status-msg.success { background: var(--success-bg); color: var(--success-text); }
  .status-msg.warning { background: var(--warning-bg); color: var(--warning-text); }
  .status-msg.error { background: var(--error-bg); color: var(--error-text); }
  .status-msg:empty { display: none; }

  /* ===== SAVED TEXTS (right column of Labels tab) ===== */
  .saved-texts-panel { display: flex; flex-direction: column; gap: 8px; }
  .saved-text-card {
    padding: 12px 14px; border: 2px solid var(--saved-card-border); border-radius: 8px;
    background: var(--saved-card-bg); cursor: pointer; transition: all 0.15s;
    box-shadow: var(--shadow);
  }
  .saved-text-card:hover { background: var(--saved-card-hover); border-color: var(--accent); }
  .saved-text-card-header {
    display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;
  }
  .saved-text-card-name { font-size: 14px; font-weight: 700; color: var(--heading); }
  .saved-text-card-actions { display: flex; gap: 2px; opacity: 0; transition: opacity 0.15s; }
  .saved-text-card:hover .saved-text-card-actions { opacity: 1; }
  .st-action-btn {
    background: none; border: none; font-size: 11px; cursor: pointer;
    padding: 2px 5px; color: var(--text-secondary); border-radius: 4px; transition: all 0.15s;
  }
  .st-action-btn:hover { color: var(--danger); background: var(--danger-bg); }
  .st-action-btn.edit:hover { color: var(--accent); background: var(--accent-bg); }

  .saved-text-card-preview {
    border: 2px solid var(--border); border-radius: 4px;
    background: var(--preview-bg); padding: 4px 6px;
    font-family: Arial, sans-serif; color: var(--preview-text);
    display: flex; flex-direction: column; overflow: hidden;
    max-height: 48px;
  }
  .saved-text-card-preview .preview-line { font-size: 9px; line-height: 1.3; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; }
  .saved-text-card-preview .preview-line.align-left { justify-content: flex-start; }
  .saved-text-card-preview .preview-line.align-center { justify-content: center; }
  .saved-text-card-preview .preview-line.align-right { justify-content: flex-end; }
  .saved-text-card-preview .preview-line.align-split { justify-content: space-between; }
  .saved-text-card-preview .preview-line.fill-line { display: flex; align-items: flex-end; gap: 2px; }
  .saved-text-card-preview .preview-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .saved-text-card-preview .preview-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid currentColor; min-width: 8px; margin-bottom: 1px; }

  .saved-texts-empty { padding: 24px 16px; text-align: center; color: var(--text-faint); font-size: 14px; }
  .saved-texts-empty .icon { font-size: 28px; display: block; margin-bottom: 6px; }

  /* ===== QUEUE ITEMS (used in print manifest within sheets tab) ===== */
  .queue-item {
    padding: 12px 14px; border: 2px solid var(--border); border-radius: 8px;
    background: var(--queue-item-bg); display: flex; align-items: center; gap: 12px;
    transition: all 0.15s; box-shadow: var(--shadow);
  }
  .queue-item:hover { border-color: var(--accent); }
  .queue-item-preview {
    border: 2px solid var(--border); border-radius: 4px;
    background: var(--preview-bg); padding: 3px 5px;
    font-family: Arial, sans-serif; color: var(--preview-text);
    display: flex; flex-direction: column; overflow: hidden;
    min-width: 80px; max-width: 120px; flex-shrink: 0;
  }
  .queue-item-preview .preview-line { font-size: 8px; line-height: 1.3; white-space: nowrap; overflow: hidden; display: flex; }
  .queue-item-preview .preview-line.align-left { justify-content: flex-start; }
  .queue-item-preview .preview-line.align-center { justify-content: center; }
  .queue-item-preview .preview-line.align-right { justify-content: flex-end; }
  .queue-item-preview .preview-line.align-split { justify-content: space-between; }
  .queue-item-preview .preview-line.fill-line { display: flex; align-items: flex-end; gap: 2px; }
  .queue-item-preview .preview-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
  .queue-item-preview .preview-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid currentColor; min-width: 8px; margin-bottom: 1px; }
  .queue-item-info { flex: 1; min-width: 0; }
  .queue-item-positions { font-size: 13px; color: var(--heading); font-weight: 600; font-family: var(--mono); }
  .queue-item-count { font-size: 12px; color: var(--text-secondary); font-weight: 600; }
  .queue-item-remove {
    background: none; border: none; font-size: 14px; color: var(--text-faint);
    cursor: pointer; padding: 4px 6px; border-radius: 4px; transition: all 0.15s;
  }
  .queue-item-remove:hover { color: var(--danger); background: var(--danger-bg); }

  .queue-empty-state { padding: 32px 16px; text-align: center; color: var(--text-faint); font-size: 14px; }
  .queue-empty-state .icon { font-size: 32px; display: block; margin-bottom: 8px; }

  .print-actions { display: flex; gap: 8px; margin-top: 4px; }

  /* ===== NEW SHEET MODAL ===== */
  .modal-overlay {
    display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.45); z-index: 1000;
    align-items: center; justify-content: center;
  }
  .modal-overlay.visible { display: flex; }
  .modal {
    background: var(--surface); border-radius: 14px; padding: 24px;
    width: 520px; max-width: 92vw; box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    max-height: 90vh; overflow-y: auto;
  }
  .modal h3 { font-size: 18px; color: var(--heading); margin-bottom: 14px; font-weight: 700; }
  .modal input[type="text"], .modal textarea {
    width: 100%; padding: 11px 14px; border: 2px solid var(--input-border); border-radius: 8px;
    background: var(--input-bg); color: var(--text); font-size: 15px;
    font-family: inherit; margin-bottom: 10px;
  }
  .modal textarea { height: 76px; resize: vertical; }
  .modal input:focus, .modal textarea:focus { outline: none; border-color: var(--accent); }
  .modal input::placeholder { color: var(--text-faint); }
  .modal-hint { font-size: 13px; color: var(--text-muted); margin: -6px 0 12px; }
  .modal-btns { display: flex; gap: 8px; }
  .modal-btns .btn { flex: 1; justify-content: center; }
  .modal-message { font-size: 15px; color: var(--text); margin-bottom: 16px; line-height: 1.5; }

  .label-type-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 14px; max-height: 280px; overflow-y: auto; }
  .label-type-card {
    padding: 10px 12px; border: 2px solid var(--type-card-border); border-radius: 8px;
    background: var(--type-card-bg); cursor: pointer; transition: all 0.15s;
  }
  .label-type-card:hover { border-color: var(--accent); }
  .label-type-card.selected { border-color: var(--type-card-active); background: var(--accent-bg); }
  .label-type-card .ltc-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
  .label-type-card .ltc-name { font-size: 14px; font-weight: 700; color: var(--heading); }
  .label-type-card .ltc-count { font-size: 12px; font-weight: 700; color: var(--accent-text); font-family: var(--mono); }
  .label-type-card .ltc-desc { font-size: 11px; color: var(--text-muted); }
  .label-type-card .ltc-dims { font-size: 12px; color: var(--text-secondary); margin-top: 2px; font-family: var(--mono); }
  .label-type-card .ltc-mini-grid { display: inline-grid; gap: 1px; margin-top: 4px; }
  .label-type-card .ltc-mini-cell { background: var(--accent); border-radius: 1px; opacity: 0.4; }
  .label-type-card.selected .ltc-mini-cell { opacity: 0.7; }

  /* Label type in compose header */
  .label-type-chip {
    font-size: 11px; font-weight: 500; color: var(--text-muted);
    background: var(--surface-alt); border: 1px solid var(--border);
    padding: 2px 8px; border-radius: 4px; font-family: var(--mono);
  }

  /* ===== SAVE NAME INPUT ===== */
  .save-name-row {
    display: flex; gap: 6px; align-items: center; margin-top: 8px;
    animation: fadeIn 0.2s ease;
  }
  .save-name-row input {
    flex: 1; padding: 7px 10px; border: 2px solid var(--input-border);
    border-radius: 6px; font-size: 14px; font-family: inherit;
    background: var(--input-bg); color: var(--text);
  }
  .save-name-row input:focus { outline: none; border-color: var(--accent); }
  .save-name-row input::placeholder { color: var(--text-faint); }

  /* ===== PRINT CSS ===== */
  @media print {
    @page { size: letter; margin: 0; }
    html, body { height: 11in !important; width: 8.5in !important; margin: 0 !important; padding: 0 !important; overflow: hidden !important; background: #fff !important; color: #000 !important; }
    body > *:not(.print-sheet) { display: none !important; height: 0 !important; width: 0 !important; overflow: hidden !important; position: absolute !important; visibility: hidden !important; }
    .print-sheet { display: block !important; visibility: visible !important; position: relative !important; width: 8.5in; height: 11in; margin: 0; padding: 0; overflow: hidden; box-sizing: border-box; }
    .print-label {
      position: absolute; overflow: hidden; font-family: Arial, sans-serif;
      line-height: 1.3; color: #000; display: flex; flex-direction: column;
      box-sizing: border-box;
    }
    .print-label .print-line { width: 100%; display: flex; white-space: nowrap; overflow: hidden; }
    .print-label .print-line.align-left { justify-content: flex-start; text-align: left; }
    .print-label .print-line.align-center { justify-content: center; text-align: center; }
    .print-label .print-line.align-right { justify-content: flex-end; text-align: right; }
    .print-label .print-line.align-split { justify-content: space-between; text-align: left; }
    .print-label .print-line.fill-line { display: flex; align-items: flex-end; gap: 3px; }
    .print-label .print-line.fill-line .fill-label { white-space: nowrap; flex-shrink: 0; }
    .print-label .print-line.fill-line .fill-rule { flex: 1; border-bottom: 1px solid #000; min-width: 0.25in; margin-bottom: 1px; }
    .print-label.empty { color: transparent; }
  }
  .print-sheet { display: none; }


  /* ===== ASSIGNED TEXTS ON SHEETS TAB ===== */
  .assigned-texts-section { margin-top: 16px; }
  .assigned-texts-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid var(--border);
  }
  .assigned-texts-title { font-size: 15px; font-weight: 700; color: var(--heading); }
  .assigned-texts-list { display: flex; flex-direction: column; gap: 8px; }
  .assigned-text-row {
    padding: 10px 12px; border: 2px solid var(--border); border-radius: 8px;
    background: var(--surface); display: flex; align-items: center; gap: 10px;
    transition: all 0.15s; box-shadow: var(--shadow-sm); cursor: default;
  }
  .assigned-text-row:hover { border-color: var(--accent); }
  .assigned-text-row.has-error { border-color: var(--danger); background: var(--danger-bg); }
  .assigned-text-color {
    width: 8px; height: 36px; border-radius: 4px; flex-shrink: 0;
  }
  .assigned-text-preview {
    border: 2px solid var(--border); border-radius: 4px;
    background: var(--preview-bg); padding: 3px 5px;
    font-family: Arial, sans-serif; color: var(--preview-text);
    display: flex; flex-direction: column; overflow: hidden;
    min-width: 70px; max-width: 100px; flex-shrink: 0;
  }
  .assigned-text-preview .preview-line { font-size: 7px; line-height: 1.3; white-space: nowrap; overflow: hidden; display: flex; }
  .assigned-text-preview .preview-line.align-left { justify-content: flex-start; }
  .assigned-text-preview .preview-line.align-center { justify-content: center; }
  .assigned-text-preview .preview-line.align-right { justify-content: flex-end; }
  .assigned-text-preview .preview-line.align-split { justify-content: space-between; }
  .assigned-text-info { flex: 1; min-width: 0; }
  .assigned-text-name {
    font-size: 14px; font-weight: 700; color: var(--heading);
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .assigned-text-spots { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
  .assigned-text-controls { display: flex; align-items: center; gap: 8px; flex-shrink: 0; flex-wrap: wrap; }
  .assigned-text-placement {
    padding: 4px 8px; border: 2px solid var(--input-border); border-radius: 5px;
    font-size: 12px; font-family: inherit; background: var(--input-bg); color: var(--text);
    cursor: pointer;
  }
  .assigned-text-placement:focus { outline: none; border-color: var(--accent); }
  .assigned-text-qty {
    display: flex; align-items: center; gap: 0; flex-shrink: 0;
  }
  .assigned-text-qty .qty-btn {
    width: 28px; height: 28px; border: 2px solid var(--border);
    background: var(--align-btn-bg); color: var(--text-secondary);
    font-size: 16px; font-weight: 700; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s; padding: 0; line-height: 1;
  }
  .assigned-text-qty .qty-btn:first-child { border-radius: 5px 0 0 5px; }
  .assigned-text-qty .qty-btn:last-child { border-radius: 0 5px 5px 0; }
  .assigned-text-qty .qty-btn:hover { border-color: var(--accent); color: var(--accent); }
  .assigned-text-qty .qty-val {
    width: 36px; height: 28px; border-top: 2px solid var(--border); border-bottom: 2px solid var(--border);
    background: var(--input-bg); color: var(--heading); font-size: 14px; font-weight: 700;
    display: flex; align-items: center; justify-content: center; user-select: none;
    font-family: var(--mono);
  }
  .assigned-text-remove {
    background: none; border: none; font-size: 14px; color: var(--text-faint);
    cursor: pointer; padding: 4px 6px; border-radius: 4px; transition: all 0.15s; flex-shrink: 0;
  }
  .assigned-text-remove:hover { color: var(--danger); background: var(--danger-bg); }
  .assigned-texts-empty {
    padding: 16px; text-align: center; color: var(--text-muted); font-size: 14px;
    border: 2px dashed var(--border); border-radius: 8px;
  }

  /* Print actions on sheets tab */
  .sheet-print-actions {
    margin-bottom: 16px; padding: 14px; border-radius: 10px;
    background: var(--surface); border: 2px solid var(--accent-soft); box-shadow: var(--shadow);
  }
  .sheet-print-error {
    margin-top: 8px; padding: 10px 14px; border-radius: 8px;
    background: var(--error-bg); border: 2px solid var(--error-border);
    font-size: 13px; font-weight: 600; color: var(--error-text); line-height: 1.5;
  }

  /* Text color palette for grid visualization */
  .cell-color-0 { background: #2a4a7a; border-color: #3a6aaa; color: #fff; }
  .cell-color-1 { background: #4a2a6a; border-color: #6a3a8a; color: #fff; }
  .cell-color-2 { background: #2a5a4a; border-color: #3a7a6a; color: #fff; }
  .cell-color-3 { background: #6a3a2a; border-color: #8a5a3a; color: #fff; }
  .cell-color-4 { background: #5a5a2a; border-color: #7a7a3a; color: #fff; }
  .cell-color-5 { background: #2a4a5a; border-color: #3a6a7a; color: #fff; }
  [data-theme="dark"] .cell-color-0 { background: #1e3a5e; border-color: #3a6090; color: #dde8ff; }
  [data-theme="dark"] .cell-color-1 { background: #3e1e5a; border-color: #5a3a80; color: #e8d8ff; }
  [data-theme="dark"] .cell-color-2 { background: #1e4a3a; border-color: #3a7060; color: #d0f0e0; }
  [data-theme="dark"] .cell-color-3 { background: #5a2e1e; border-color: #804838; color: #ffe0d0; }
  [data-theme="dark"] .cell-color-4 { background: #4a4a1e; border-color: #707038; color: #f0f0d0; }
  [data-theme="dark"] .cell-color-5 { background: #1e3a4a; border-color: #386070; color: #d0e8f0; }
  .color-swatch-0 { background: #3a6aaa; }
  .color-swatch-1 { background: #6a3a8a; }
  .color-swatch-2 { background: #3a7a6a; }
  .color-swatch-3 { background: #8a5a3a; }
  .color-swatch-4 { background: #7a7a3a; }
  .color-swatch-5 { background: #386070; }

  /* Sheet selector dropdown on texts tab */
  .sheet-selector {
    display: flex; align-items: center; gap: 8px; margin-bottom: 12px;
  }
  .sheet-selector label { font-size: 13px; font-weight: 600; color: var(--text-muted); white-space: nowrap; }
  .sheet-selector select {
    flex: 1; padding: 7px 10px; border: 2px solid var(--input-border); border-radius: 6px;
    font-size: 14px; font-family: inherit; background: var(--input-bg); color: var(--text);
    cursor: pointer;
  }
  .sheet-selector select:focus { outline: none; border-color: var(--accent); }

  /* Grid dynamic styles injected here */
  /* Responsive */
  @media (max-width: 768px) {
    .sheets-layout, .labels-layout {
      grid-template-columns: 1fr;
    }
    .tab-meta { display: none; }
    .tab-btn { padding: 10px 14px; font-size: 14px; }
  }

</style>
<style id="dynamicGridStyle"></style>
</head>
<body>

<div class="app-shell">
  <div class="app-topbar">
    <div class="app-title">
      üìã Teach Assist <span class="version">v1.0.0</span>
    </div>
    <div class="topbar-actions">
      <div class="hamburger-menu" id="hamburgerMenu">
        <button class="hamburger-btn" onclick="toggleHamburger()" title="Menu">‚ò∞</button>
        <div class="hamburger-dropdown" id="hamburgerDropdown">
          <button class="hamburger-item" onclick="toggleTheme()">
            <span class="hamburger-item-label" id="themeMenuLabel">üåô Dark Mode</span>
            <div class="toggle-track" id="themeToggleTrack"><div class="toggle-thumb"><span id="toggleIcon">‚òÄÔ∏è</span></div></div>
          </button>
          <button class="hamburger-item" onclick="exportData()">
            <span class="hamburger-item-label">üì§ Export Data</span>
          </button>
          <button class="hamburger-item" onclick="importData()">
            <span class="hamburger-item-label">üì• Import Data</span>
          </button>
          <button class="hamburger-item" onclick="showAboutModal()">
            <span class="hamburger-item-label">‚ÑπÔ∏è About</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-bar">
    <button class="tab-btn active" data-tab="sheets" onclick="switchTab('sheets')">
      Sheets <span class="tab-meta" id="tabMetaSheets"></span>
    </button>
    <button class="tab-btn" data-tab="texts" onclick="switchTab('texts')">
      Texts <span class="tab-meta" id="tabMetaTexts"></span>
    </button>
  </div>

  <!-- ==================== SHEETS TAB ==================== -->
  <div class="tab-panel active" id="panelSheets">
    <div class="sheets-layout">
      <div>
        <div class="sheets-col-header">
          Your Sheets
          <button class="btn btn-primary btn-sm" onclick="showNewSheetModal()">+ New Sheet</button>
        </div>
        <div class="sheet-cards" id="sheetCardsList"></div>
        <div id="sheetAssignedArea"></div>
      </div>
      <div>
        <div class="sheets-col-header">Sheet Map</div>
        <div id="sheetDetailArea"></div>
      </div>
    </div>
  </div>

  <!-- ==================== TEXTS TAB ==================== -->
  <div class="tab-panel" id="panelTexts">
    <div class="labels-layout">
      <div class="compose-panel">
        <div class="panel-section">
          <div class="panel-section-title">
            Compose Text
            <span class="label-type-chip" id="composeTypeChip"></span>
          </div>

          <div id="editingIndicator" style="display:none"></div>

          <div class="sheet-selector">
            <label>Preview on:</label>
            <select id="previewSheetSelect" onchange="onPreviewSheetChange()"></select>
          </div>

          <div class="emoji-picker-section">
            <button class="emoji-toggle-btn" id="emojiToggle" onclick="toggleEmojiPanel()">üòÄ Emoji</button>
            <div class="emoji-panel" id="emojiPanel">
              <input type="text" class="emoji-panel-search" id="emojiSearch" placeholder="Search emoji‚Ä¶" oninput="filterEmojis()">
              <div class="emoji-scroll" id="emojiScroll"></div>
            </div>
          </div>

          <div id="lineInputsArea">
            <div class="line-input-row">
              <span class="line-num">1</span>
              <input type="text" id="line1" placeholder="Line 1 ‚Äî use || to split, __ for fill line" oninput="updatePreview()" maxlength="80">
              <button class="line-align-btn active" id="align1_left" onclick="setLineAlign(1,'left')" title="Left">‚Üê</button>
              <button class="line-align-btn" id="align1_center" onclick="setLineAlign(1,'center')" title="Center">‚Ä¢</button>
              <button class="line-align-btn" id="align1_right" onclick="setLineAlign(1,'right')" title="Right">‚Üí</button>
              <div class="line-size-stepper"><button class="size-btn" onclick="stepSize(1,-1)">‚àí</button><span class="size-val" id="size1">11</span><button class="size-btn" onclick="stepSize(1,1)">+</button></div>
            </div>
            <div class="line-input-row">
              <span class="line-num">2</span>
              <input type="text" id="line2" placeholder="Line 2" oninput="updatePreview()" maxlength="80">
              <button class="line-align-btn active" id="align2_left" onclick="setLineAlign(2,'left')" title="Left">‚Üê</button>
              <button class="line-align-btn" id="align2_center" onclick="setLineAlign(2,'center')" title="Center">‚Ä¢</button>
              <button class="line-align-btn" id="align2_right" onclick="setLineAlign(2,'right')" title="Right">‚Üí</button>
              <div class="line-size-stepper"><button class="size-btn" onclick="stepSize(2,-1)">‚àí</button><span class="size-val" id="size2">11</span><button class="size-btn" onclick="stepSize(2,1)">+</button></div>
            </div>
            <div class="line-input-row">
              <span class="line-num">3</span>
              <input type="text" id="line3" placeholder="Line 3" oninput="updatePreview()" maxlength="80">
              <button class="line-align-btn active" id="align3_left" onclick="setLineAlign(3,'left')" title="Left">‚Üê</button>
              <button class="line-align-btn" id="align3_center" onclick="setLineAlign(3,'center')" title="Center">‚Ä¢</button>
              <button class="line-align-btn" id="align3_right" onclick="setLineAlign(3,'right')" title="Right">‚Üí</button>
              <div class="line-size-stepper"><button class="size-btn" onclick="stepSize(3,-1)">‚àí</button><span class="size-val" id="size3">11</span><button class="size-btn" onclick="stepSize(3,1)">+</button></div>
            </div>
            <div class="line-input-row">
              <span class="line-num">4</span>
              <input type="text" id="line4" placeholder="Line 4" oninput="updatePreview()" maxlength="80">
              <button class="line-align-btn active" id="align4_left" onclick="setLineAlign(4,'left')" title="Left">‚Üê</button>
              <button class="line-align-btn" id="align4_center" onclick="setLineAlign(4,'center')" title="Center">‚Ä¢</button>
              <button class="line-align-btn" id="align4_right" onclick="setLineAlign(4,'right')" title="Right">‚Üí</button>
              <div class="line-size-stepper"><button class="size-btn" onclick="stepSize(4,-1)">‚àí</button><span class="size-val" id="size4">11</span><button class="size-btn" onclick="stepSize(4,1)">+</button></div>
            </div>
            <div class="line-inputs-hint">Use <code>||</code> to split a line &nbsp;¬∑&nbsp; Use <code>__</code> for a fill line, e.g. <code>Name__</code></div>
          </div>

          <div class="controls-row" style="margin-top: 10px;">
            <div class="control-group">
              <span class="control-group-label">Vertical:</span>
              <button class="align-btn" data-align-v="top" onclick="setAlignV('top')">‚Üë</button>
              <button class="align-btn active" data-align-v="center" onclick="setAlignV('center')">‚Äî</button>
              <button class="align-btn" data-align-v="bottom" onclick="setAlignV('bottom')">‚Üì</button>
              <button class="align-btn" data-align-v="spread" onclick="setAlignV('spread')">‚Üï</button>
            </div>
          </div>

          <div class="preview-container" style="margin-top: 10px;">
            <div class="preview-label empty-preview" id="previewLabel"><span>Type above to preview</span></div>
          </div>
          <div class="preview-dimensions" id="previewDimensions"></div>

          <div class="compose-actions">
            <button class="btn btn-primary" style="flex:1;display:none" onclick="saveCurrentText()" id="saveTextBtn">üíæ Save Text</button>
          </div>

          <div id="saveNameRow" style="display:none"></div>
          <div id="statusMsg" class="status-msg" style="margin-top:8px"></div>

          <div id="addToSheetRow" style="display:none"></div>
        </div>
      </div>

      <div>
        <div class="sheets-col-header">
          Saved Texts
          <span style="font-size:11px;font-weight:500;color:var(--text-faint)" id="savedTextsCount"></span>
        </div>
        <div class="saved-texts-panel" id="savedTextsList"></div>
      </div>
    </div>
  </div>

  <!-- Print tab removed in v10 ‚Äî printing is now on Sheets tab -->
</div>

<div class="print-sheet" id="printSheet"></div>

<!-- New Sheet Modal -->
<div class="modal-overlay" id="newSheetModal">
  <div class="modal">
    <h3 id="newSheetModalTitle">üìÑ New Label Sheet</h3>
    <input type="text" id="newSheetName" placeholder="Sheet name (e.g., Science Class, Holiday Cards)">
    <div class="modal-hint">Choose a label type:</div>
    <div class="label-type-grid" id="labelTypeGrid"></div>
    <div class="modal-btns">
      <button class="btn btn-secondary" id="newSheetCancelBtn" onclick="closeModal('newSheetModal')">Cancel</button>
      <button class="btn btn-primary" onclick="createNewSheet()">Create Sheet</button>
    </div>
  </div>
</div>

<!-- Add Text to Sheet Modal -->
<div class="modal-overlay" id="addTextModal">
  <div class="modal">
    <h3 id="addTextModalTitle">üìé Add Text to Sheet</h3>
    <div class="modal-message" id="addTextModalMsg"></div>
    <div id="addTextPickerList" style="max-height:300px;overflow-y:auto;margin-bottom:14px"></div>
    <div class="modal-btns">
      <button class="btn btn-secondary" onclick="closeModal('addTextModal')">Cancel</button>
    </div>
  </div>
</div>

<!-- Generic Dialog -->
<div class="modal-overlay" id="dialogModal">
  <div class="modal">
    <h3 id="dialogTitle">Confirm</h3>
    <div class="modal-message" id="dialogMessage"></div>
    <input type="text" id="dialogInput" style="display:none">
    <div class="modal-btns">
      <button class="btn btn-secondary" id="dialogCancelBtn" onclick="dialogResolve(false)">Cancel</button>
      <button class="btn btn-primary" id="dialogOkBtn" onclick="dialogResolve(true)">OK</button>
    </div>
  </div>
</div>

<!-- About Modal -->
<div class="modal-overlay" id="aboutModal">
  <div class="modal" style="max-width:420px">
    <h3>üìã Teach Assist</h3>
    <div style="font-size:14px;color:var(--text-secondary);line-height:1.7">
      <div style="margin-bottom:12px"><strong style="color:var(--heading)">Version 1.0.0</strong></div>
      <p>A tool for printing labels on Avery-compatible label sheets. Tracks partially-used sheets so no labels are wasted.</p>
      <p style="margin-top:10px">Supports 9 Avery formats, reusable text templates, per-line formatting, column-based placement control, and data import/export.</p>
      <p style="margin-top:10px;font-size:13px;color:var(--text-muted)">All data is stored locally in your browser. Nothing is sent to any server.</p>
    </div>
    <div class="modal-btns" style="margin-top:16px">
      <button class="btn btn-primary" onclick="closeModal('aboutModal')">Close</button>
    </div>
  </div>
</div>

<script>
// ========== LABEL TYPE SPECIFICATIONS ==========
const LABEL_TYPES = {
  '5160': { name: '5160 / 8160', desc: 'Standard Address', labelW: 2.625, labelH: 1, cols: 3, rows: 10, topMargin: 0.5, leftMargin: 0.1875, hGutter: 0.125, vGutter: 0, sizeDisplay: '1‚Ä≥ √ó 2‚Öù‚Ä≥', layoutDisplay: '3 √ó 10' },
  '5161': { name: '5161 / 8161', desc: 'Address + Logo', labelW: 4, labelH: 1, cols: 2, rows: 10, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1‚Ä≥ √ó 4‚Ä≥', layoutDisplay: '2 √ó 10' },
  '5162': { name: '5162 / 8162', desc: 'Large Address', labelW: 4, labelH: 1.333, cols: 2, rows: 7, topMargin: 0.8335, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '1‚Öì‚Ä≥ √ó 4‚Ä≥', layoutDisplay: '2 √ó 7' },
  '5163': { name: '5163 / 8163', desc: 'Shipping', labelW: 4, labelH: 2, cols: 2, rows: 5, topMargin: 0.5, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '2‚Ä≥ √ó 4‚Ä≥', layoutDisplay: '2 √ó 5' },
  '5164': { name: '5164 / 8164', desc: 'Large Shipping', labelW: 4, labelH: 3.333, cols: 2, rows: 3, topMargin: 0.5005, leftMargin: 0.15625, hGutter: 0.1875, vGutter: 0, sizeDisplay: '3‚Öì‚Ä≥ √ó 4‚Ä≥', layoutDisplay: '2 √ó 3' },
  '5167': { name: '5167 / 8167', desc: 'Return Address (tiny)', labelW: 1.75, labelH: 0.5, cols: 4, rows: 20, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: '¬Ω‚Ä≥ √ó 1¬æ‚Ä≥', layoutDisplay: '4 √ó 20' },
  '5168': { name: '5168 / 8168', desc: 'Extra Large Shipping', labelW: 3.5, labelH: 5, cols: 2, rows: 2, topMargin: 0.5, leftMargin: 0.5, hGutter: 0.5, vGutter: 0, sizeDisplay: '3¬Ω‚Ä≥ √ó 5‚Ä≥', layoutDisplay: '2 √ó 2' },
  '5195': { name: '5195 / 8195', desc: 'Small Return Address', labelW: 1.75, labelH: 0.667, cols: 4, rows: 15, topMargin: 0.5, leftMargin: 0.28125, hGutter: 0.3125, vGutter: 0, sizeDisplay: '‚Öî‚Ä≥ √ó 1¬æ‚Ä≥', layoutDisplay: '4 √ó 15' },
  '5165': { name: '5165', desc: 'Full Sheet', labelW: 8.5, labelH: 11, cols: 1, rows: 1, topMargin: 0, leftMargin: 0, hGutter: 0, vGutter: 0, sizeDisplay: '8¬Ω‚Ä≥ √ó 11‚Ä≥', layoutDisplay: '1 √ó 1' }
};
const TYPE_ORDER = ['5160','5163','5164','5161','5162','5167','5195','5168','5165'];
const TEXT_COLORS = ['#3a6aaa','#6a3a8a','#3a7a6a','#8a5a3a','#7a7a3a','#386070'];

const SHEETS_KEY = 'avery_sheets_v6';
const ACTIVE_KEY = 'avery_active_v6';
const THEME_KEY = 'avery5160_theme';
const TEXTS_KEY = 'avery5160_saved_texts';

let sheets = {};
let activeSheetId = null;
let alignV = 'center';
let lineAligns = ['left','left','left','left'];
let lineFontSizes = [11,11,11,11];
let savedTexts = [];
let editingTextId = null;
let newSheetLabelType = '5160';
let firstRunRequired = false;
let currentTab = 'sheets';
let previewSheetId = null; // which sheet the texts tab previews against
let lastPrintJob = null;  // { sheetId, indices, textQtys } for undo

// ========== HELPERS ==========
function getSpec(typeId) { return LABEL_TYPES[typeId || '5160']; }
function getSheet(id) { return sheets[id] || null; }
function getActiveSheet() { return sheets[activeSheetId] || { name: 'Unknown', printed: [], labelType: '5160', texts: {} }; }
function getActiveSpec() { return getSpec(getActiveSheet().labelType); }
function getTotal(sh) { sh = sh || getActiveSheet(); const s = getSpec(sh.labelType); return s.cols * s.rows; }
function getPrinted(sh) { sh = sh || getActiveSheet(); return sh.printed || []; }
function getRemaining(sh) { return getTotal(sh) - getPrinted(sh).length; }
function getSavedText(id) { return savedTexts.find(t => t.id === id) || null; }

// Get total qty assigned to a sheet across all its texts
function getAssignedCount(sh) {
  sh = sh || getActiveSheet();
  if (!sh.texts) return 0;
  return Object.values(sh.texts).reduce((sum, t) => sum + (t.qty || 0), 0);
}

// Get available spots on a sheet (remaining - already assigned)
function getAvailableSpots(sh) {
  return Math.max(0, getRemaining(sh) - getAssignedCount(sh));
}

// Build position assignments for a sheet: derive which indices each text gets
// Returns { assignments: { textId: [indices] }, errors: [{ textId, message }] }
function buildAssignments(sh) {
  sh = sh || getActiveSheet();
  const spec = getSpec(sh.labelType);
  const total = spec.cols * spec.rows;
  const printed = new Set(sh.printed || []);
  const assignments = {};
  const errors = [];
  const used = new Set();

  if (!sh.texts) return { assignments, errors };

  const textIds = Object.keys(sh.texts);

  // First pass: place column-specific texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0 || placement === 'next') { continue; }

    // placement is 'col:N' (1-indexed)
    const colNum = parseInt(placement.split(':')[1]) - 1;
    if (colNum < 0 || colNum >= spec.cols) {
      assignments[textId] = [];
      errors.push({ textId, message: 'Column ' + (colNum+1) + ' does not exist on this sheet type' });
      continue;
    }
    const indices = [];
    for (let r = 0; r < spec.rows && indices.length < qty; r++) {
      const idx = r * spec.cols + colNum;
      if (!printed.has(idx) && !used.has(idx)) {
        indices.push(idx);
        used.add(idx);
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' in Column ' + (colNum+1) + ' but only ' + indices.length + ' available' });
    }
  }

  // Second pass: place "next available" texts
  for (const textId of textIds) {
    const entry = sh.texts[textId];
    const qty = entry.qty || 0;
    const placement = entry.placement || 'next';
    if (qty <= 0) { assignments[textId] = assignments[textId] || []; continue; }
    if (placement !== 'next') continue;

    const indices = [];
    for (let i = 0; i < total && indices.length < qty; i++) {
      if (!printed.has(i) && !used.has(i)) {
        indices.push(i);
        used.add(i);
      }
    }
    assignments[textId] = indices;
    if (indices.length < qty) {
      errors.push({ textId, message: 'Needs ' + qty + ' spots but only ' + indices.length + ' available' });
    }
  }

  // Ensure all textIds have an entry
  for (const textId of textIds) {
    if (!assignments[textId]) assignments[textId] = [];
  }

  return { assignments, errors };
}

function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }
function escapeAttr(t) { return t.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\n/g, ' '); }
function generateId(prefix) { return (prefix || 'sh') + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5); }
function getFlexAlign(v) { return v === 'spread' ? 'space-between' : v === 'top' || v === 'left' ? 'flex-start' : v === 'bottom' || v === 'right' ? 'flex-end' : 'center'; }

// ========== CUSTOM DIALOGS ==========
let _dialogResolveFn = null;
let _dialogMode = 'confirm';

function showDialog({ title, message, okText, cancelText, mode, inputValue, inputPlaceholder, danger }) {
  _dialogMode = mode || 'confirm';
  const modal = document.getElementById('dialogModal');
  document.getElementById('dialogTitle').textContent = title || 'Confirm';
  document.getElementById('dialogMessage').textContent = message || '';
  const okBtn = document.getElementById('dialogOkBtn');
  const cancelBtn = document.getElementById('dialogCancelBtn');
  const input = document.getElementById('dialogInput');
  okBtn.textContent = okText || 'OK';
  if (danger) { okBtn.style.background = 'var(--danger)'; okBtn.style.borderColor = 'var(--danger)'; }
  else { okBtn.style.background = ''; okBtn.style.borderColor = ''; }
  cancelBtn.textContent = cancelText || 'Cancel';
  cancelBtn.style.display = mode === 'alert' ? 'none' : '';
  if (mode === 'prompt') { input.style.display = ''; input.value = inputValue || ''; input.placeholder = inputPlaceholder || ''; }
  else { input.style.display = 'none'; }
  modal.classList.add('visible');
  if (mode === 'prompt') input.focus(); else okBtn.focus();
  return new Promise(resolve => { _dialogResolveFn = resolve; });
}
function dialogResolve(confirmed) {
  const input = document.getElementById('dialogInput');
  document.getElementById('dialogModal').classList.remove('visible');
  if (!_dialogResolveFn) return;
  const fn = _dialogResolveFn; _dialogResolveFn = null;
  if (_dialogMode === 'prompt') fn(confirmed ? input.value : null);
  else fn(confirmed);
}
document.addEventListener('keydown', e => {
  if (!document.getElementById('dialogModal').classList.contains('visible')) return;
  if (e.key === 'Enter') { e.preventDefault(); dialogResolve(true); }
  if (e.key === 'Escape') { dialogResolve(_dialogMode === 'alert'); }
});
function showConfirm(message, opts = {}) { return showDialog({ title: opts.title || 'Confirm', message, okText: opts.okText || 'Yes', cancelText: opts.cancelText || 'Cancel', mode: 'confirm', danger: opts.danger }); }
function showPrompt(message, defaultVal, opts = {}) { return showDialog({ title: opts.title || 'Input', message, mode: 'prompt', inputValue: defaultVal, inputPlaceholder: opts.placeholder || '', okText: opts.okText || 'OK' }); }
function showAlert(message, opts = {}) { return showDialog({ title: opts.title || 'Notice', message, mode: 'alert', okText: opts.okText || 'OK' }); }

// ========== TAB NAVIGATION ==========
function switchTab(tab) {
  if (!activeSheetId && tab !== 'sheets') return;
  // If leaving texts tab with unsaved changes, offer 3 choices
  if (currentTab === 'texts' && tab !== 'texts' && isComposeDirty()) {
    showDirtyNavigationDialog(editingTextId).then(choice => {
      if (choice === 'save') {
        // Save changes then navigate
        if (editingTextId) {
          const existing = savedTexts.find(s => s.id === editingTextId);
          if (existing) {
            existing.text = serializeLines(getLines());
            existing.alignV = alignV;
            saveSavedTexts(); renderSavedTexts();
            setStatus('Saved "' + existing.name + '" and switched tabs', 'success');
          }
        }
        // For new unsaved text, we can't auto-save (no name yet) ‚Äî just navigate
        doSwitchTab(tab);
      } else if (choice === 'discard') {
        doSwitchTab(tab);
      }
      // 'stay' ‚Äî do nothing
    });
    return;
  }
  doSwitchTab(tab);
}

function showDirtyNavigationDialog(isEditing) {
  return new Promise(resolve => {
    const name = isEditing ? (savedTexts.find(s => s.id === isEditing)?.name || 'text') : null;
    const title = '‚ö†Ô∏è Unsaved Changes';
    const message = isEditing
      ? 'You have unsaved changes to "' + name + '".'
      : 'You have unsaved text in the compose area.';

    const modal = document.getElementById('dialogModal');
    document.getElementById('dialogTitle').textContent = title;
    document.getElementById('dialogMessage').textContent = message;
    document.getElementById('dialogInput').style.display = 'none';

    const btnsDiv = modal.querySelector('.modal-btns');
    const originalHtml = btnsDiv.innerHTML;
    btnsDiv.innerHTML = '';

    function finish(choice) { closeModal('dialogModal'); btnsDiv.innerHTML = originalHtml; resolve(choice); }

    const stayBtn = document.createElement('button');
    stayBtn.className = 'btn btn-secondary';
    stayBtn.textContent = 'Stay';
    stayBtn.onclick = () => finish('stay');
    btnsDiv.appendChild(stayBtn);

    if (isEditing) {
      const saveBtn = document.createElement('button');
      saveBtn.className = 'btn btn-primary';
      saveBtn.textContent = 'üíæ Save & Go';
      saveBtn.onclick = () => finish('save');
      btnsDiv.appendChild(saveBtn);
    }

    const discardBtn = document.createElement('button');
    discardBtn.className = 'btn btn-danger';
    discardBtn.textContent = 'Discard & Go';
    discardBtn.onclick = () => finish('discard');
    btnsDiv.appendChild(discardBtn);

    modal.classList.add('visible');
  });
}

function doSwitchTab(tab) {
  currentTab = tab;
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
  document.getElementById('panel' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
  updateTabMeta();

  if (tab === 'texts') { buildPreviewSheetSelect(); updatePreview(); }
  if (tab === 'sheets') { buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); }
}

function updateTabMeta() {
  const sheetsMeta = document.getElementById('tabMetaSheets');
  if (activeSheetId) {
    const sh = getActiveSheet();
    sheetsMeta.textContent = '¬∑ ' + sh.name + ' (' + getRemaining() + ' left)';
  } else {
    sheetsMeta.textContent = '¬∑ No sheet selected';
  }
  const textsMeta = document.getElementById('tabMetaTexts');
  textsMeta.textContent = savedTexts.length ? '¬∑ ' + savedTexts.length + ' saved' : '';
}

// ========== THEME ==========
function initTheme() {
  const s = localStorage.getItem(THEME_KEY);
  if (s === 'dark') document.documentElement.setAttribute('data-theme','dark');
  else if (s === 'light') document.documentElement.removeAttribute('data-theme');
  else if (matchMedia('(prefers-color-scheme:dark)').matches) document.documentElement.setAttribute('data-theme','dark');
  updateThemeUI();
}
function toggleTheme() {
  const d = document.documentElement.getAttribute('data-theme') === 'dark';
  if (d) { document.documentElement.removeAttribute('data-theme'); localStorage.setItem(THEME_KEY,'light'); }
  else { document.documentElement.setAttribute('data-theme','dark'); localStorage.setItem(THEME_KEY,'dark'); }
  updateThemeUI();
}
function updateThemeUI() {
  const d = document.documentElement.getAttribute('data-theme') === 'dark';
  const track = document.getElementById('themeToggleTrack');
  const label = document.getElementById('themeMenuLabel');
  const icon = document.getElementById('toggleIcon');
  if (track) track.classList.toggle('active', d);
  if (label) label.innerHTML = (d ? '‚òÄÔ∏è' : 'üåô') + ' ' + (d ? 'Light Mode' : 'Dark Mode');
  if (icon) icon.textContent = d ? 'üåô' : '‚òÄÔ∏è';
}

// ========== HAMBURGER MENU ==========
function toggleHamburger() {
  document.getElementById('hamburgerDropdown').classList.toggle('visible');
}
document.addEventListener('click', function(e) {
  const menu = document.getElementById('hamburgerMenu');
  if (menu && !menu.contains(e.target)) {
    document.getElementById('hamburgerDropdown').classList.remove('visible');
  }
});
function showAboutModal() {
  document.getElementById('hamburgerDropdown').classList.remove('visible');
  document.getElementById('aboutModal').classList.add('visible');
}

// ========== IMPORT / EXPORT ==========
function exportData() {
  document.getElementById('hamburgerDropdown').classList.remove('visible');
  const data = {
    version: 11,
    exportedAt: new Date().toISOString(),
    sheets: sheets,
    activeSheetId: activeSheetId,
    savedTexts: savedTexts,
    theme: localStorage.getItem(THEME_KEY) || 'light'
  };
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'label-printer-backup-' + new Date().toISOString().slice(0, 10) + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  setStatus('Data exported successfully', 'success');
}

function importData() {
  document.getElementById('hamburgerDropdown').classList.remove('visible');
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      // Validate structure
      if (!data.sheets || !data.savedTexts) {
        showAlert('Invalid backup file ‚Äî missing sheets or saved texts data.', { title: '‚ö†Ô∏è Import Failed' });
        return;
      }
      const sheetCount = Object.keys(data.sheets).length;
      const textCount = data.savedTexts.length;
      const ok = await showConfirm(
        'Import ' + sheetCount + ' sheet' + (sheetCount !== 1 ? 's' : '') + ' and ' + textCount + ' saved text' + (textCount !== 1 ? 's' : '') + '? This will replace all current data.',
        { title: 'üì• Import Data', okText: 'Import', danger: true }
      );
      if (!ok) return;
      // Apply data
      sheets = data.sheets || {};
      savedTexts = data.savedTexts || [];
      activeSheetId = data.activeSheetId || Object.keys(sheets)[0] || null;
      // Run migrations on imported data
      for (const sh of Object.values(sheets)) {
        if (!sh.labelType) sh.labelType = '5160';
        if (!sh.texts) sh.texts = {};
        for (const entry of Object.values(sh.texts)) {
          if (!entry.placement) entry.placement = 'next';
        }
      }
      if (data.theme) localStorage.setItem(THEME_KEY, data.theme);
      saveSheets();
      saveSavedTexts();
      initTheme();
      lastPrintJob = null;
      // Rebuild everything
      if (Object.keys(sheets).length) {
        buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); renderSavedTexts(); updateTabMeta();
        setStatus('Imported ' + sheetCount + ' sheet' + (sheetCount !== 1 ? 's' : '') + ' and ' + textCount + ' text' + (textCount !== 1 ? 's' : ''), 'success');
      } else {
        firstRunRequired = true;
        buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); renderSavedTexts(); updateTabMeta();
        showNewSheetModal();
      }
    } catch (err) {
      showAlert('Could not read file: ' + err.message, { title: '‚ö†Ô∏è Import Failed' });
    }
  };
  input.click();
}

// ========== LINE INPUT SYSTEM ==========
function getLines() {
  const lines = [];
  for (let i = 1; i <= 4; i++) {
    const val = document.getElementById('line' + i).value;
    if (val.trim()) lines.push({ text: val.trim(), align: lineAligns[i - 1], fontSize: lineFontSizes[i - 1] });
  }
  return lines;
}
function parseLine(text) {
  if (text.includes('||')) {
    const parts = text.split('||').map(s => s.trim());
    return { type: 'split', left: parts[0], right: parts.slice(1).join(' ').trim() };
  }
  if (text.includes('__')) {
    const idx = text.indexOf('__');
    return { type: 'fill', label: text.substring(0, idx), trailing: text.substring(idx + 2).trim() };
  }
  return { type: 'normal', text };
}
function serializeLines(lines) { return lines.map(l => l.align + ',' + (l.fontSize || 11) + ':' + l.text).join('\n'); }
function deserializeLines(str) {
  if (!str) return [];
  return str.split('\n').filter(s => s.trim()).map(s => {
    const m2 = s.match(/^(left|center|right),(\d+):(.*)$/);
    if (m2) return { text: m2[3], align: m2[1], fontSize: parseInt(m2[2]) || 11 };
    const m = s.match(/^(left|center|right):(.*)$/);
    if (m) return { text: m[2], align: m[1], fontSize: 11 };
    return { text: s, align: 'left', fontSize: 11 };
  });
}
function getFlatText(lines) { return lines.map(l => l.text).join(' / '); }

function loadLinesIntoInputs(lines) {
  for (let i = 1; i <= 4; i++) { document.getElementById('line' + i).value = ''; setLineAlign(i, 'left'); setLineSize(i, 11); }
  lines.forEach((l, idx) => {
    if (idx < 4) { document.getElementById('line' + (idx + 1)).value = l.text; setLineAlign(idx + 1, l.align || 'left'); setLineSize(idx + 1, l.fontSize || 11); }
  });
  updatePreview();
}
function clearInputs() {
  for (let i = 1; i <= 4; i++) { document.getElementById('line' + i).value = ''; setLineAlign(i, 'left'); setLineSize(i, 11); }
  editingTextId = null;
  document.getElementById('editingIndicator').style.display = 'none';
  updatePreview();
}
function hasAnyInput() {
  for (let i = 1; i <= 4; i++) { if (document.getElementById('line' + i).value.trim()) return true; }
  return false;
}
function setLineAlign(lineNum, align) {
  lineAligns[lineNum - 1] = align;
  ['left','center','right'].forEach(a => { document.getElementById('align' + lineNum + '_' + a).classList.toggle('active', a === align); });
  updatePreview();
}
function stepSize(lineNum, delta) {
  let val = lineFontSizes[lineNum - 1] + delta;
  val = Math.max(7, Math.min(16, val));
  lineFontSizes[lineNum - 1] = val;
  document.getElementById('size' + lineNum).textContent = val;
  updatePreview();
}
function setLineSize(lineNum, size) {
  lineFontSizes[lineNum - 1] = Math.max(7, Math.min(16, size));
  document.getElementById('size' + lineNum).textContent = lineFontSizes[lineNum - 1];
}
function setAlignV(v) { alignV = v; document.querySelectorAll('[data-align-v]').forEach(b => b.classList.toggle('active', b.dataset.alignV === v)); updatePreview(); }

// ========== EMOJI PICKER ==========
const EMOJI_DATA = [
  { cat: 'Common', emojis: [
    { e: '‚≠ê', n: 'star' }, { e: '‚ù§Ô∏è', n: 'heart love' }, { e: '‚úÖ', n: 'check done' }, { e: '‚ùå', n: 'x cross no' },
    { e: '‚ö†Ô∏è', n: 'warning caution' }, { e: 'üìå', n: 'pin pushpin' }, { e: 'üî¥', n: 'red circle' }, { e: 'üü¢', n: 'green circle' },
    { e: 'üîµ', n: 'blue circle' }, { e: 'üü°', n: 'yellow circle' }, { e: '‚¨õ', n: 'black square' }, { e: '‚¨ú', n: 'white square' },
    { e: '‚ñ∂Ô∏è', n: 'play arrow right' }, { e: '‚óÄÔ∏è', n: 'left arrow' }, { e: 'üîπ', n: 'diamond blue' }, { e: 'üî∏', n: 'diamond orange' },
  ]},
  { cat: 'School', emojis: [
    { e: 'üìö', n: 'books reading' }, { e: 'üìñ', n: 'open book reading' }, { e: 'üéí', n: 'backpack school bag' }, { e: '‚úÇÔ∏è', n: 'scissors craft' },
    { e: 'üìê', n: 'triangle ruler math' }, { e: 'üìè', n: 'ruler measure' }, { e: 'üñçÔ∏è', n: 'crayon color draw' }, { e: 'üñåÔ∏è', n: 'paintbrush art' },
    { e: 'üé®', n: 'art palette paint color' }, { e: 'üî¨', n: 'microscope science' }, { e: 'üß™', n: 'test tube science lab' }, { e: 'üßÆ', n: 'abacus math count' },
    { e: 'üéµ', n: 'music note' }, { e: 'üé∂', n: 'music notes' }, { e: 'üèÖ', n: 'medal award' }, { e: 'üèÜ', n: 'trophy winner award' },
    { e: 'üìì', n: 'notebook journal' }, { e: 'üñäÔ∏è', n: 'pen write' }, { e: '‚úèÔ∏è', n: 'pencil write' }, { e: 'üìù', n: 'memo note write' },
    { e: 'üß©', n: 'puzzle piece' }, { e: 'üé≤', n: 'dice game' }, { e: 'üß∏', n: 'teddy bear toy' }, { e: 'ü™Å', n: 'kite play' },
    { e: 'üçé', n: 'apple teacher' }, { e: 'üêõ', n: 'caterpillar bug insect' }, { e: 'üê∏', n: 'frog animal' }, { e: 'üê¢', n: 'turtle animal slow' },
    { e: 'ü¶ï', n: 'dinosaur dino' }, { e: 'üêù', n: 'bee honeybee insect' }, { e: 'üêû', n: 'ladybug insect' }, { e: 'ü¶Å', n: 'lion animal' },
  ]},
  { cat: 'People', emojis: [
    { e: 'üòÄ', n: 'smile happy' }, { e: 'üòä', n: 'blush smile' }, { e: 'üëã', n: 'wave hello' }, { e: 'üëç', n: 'thumbs up' },
    { e: 'üëé', n: 'thumbs down' }, { e: 'üëè', n: 'clap hands' }, { e: 'üôè', n: 'pray thanks' }, { e: 'üí™', n: 'strong muscle' },
    { e: 'üéâ', n: 'party celebrate' }, { e: 'üéÇ', n: 'birthday cake' }, { e: 'üë§', n: 'person silhouette' }, { e: 'üë•', n: 'people group' },
  ]},
  { cat: 'Office', emojis: [
    { e: 'üìÅ', n: 'folder file' }, { e: 'üìÇ', n: 'open folder' }, { e: 'üìã', n: 'clipboard' }, { e: 'üìé', n: 'paperclip' },
    { e: '‚úèÔ∏è', n: 'pencil edit' }, { e: 'üñäÔ∏è', n: 'pen' }, { e: 'üìù', n: 'memo note' }, { e: 'üìä', n: 'chart graph' },
    { e: 'üìÖ', n: 'calendar date' }, { e: 'üóìÔ∏è', n: 'calendar spiral' }, { e: 'üìá', n: 'card index' }, { e: 'üè∑Ô∏è', n: 'label tag' },
    { e: 'üì¶', n: 'box package' }, { e: 'üóÇÔ∏è', n: 'dividers tabs' }, { e: 'üîë', n: 'key' }, { e: 'üîí', n: 'lock' },
  ]},
  { cat: 'Places', emojis: [
    { e: 'üè†', n: 'home house' }, { e: 'üè¢', n: 'office building' }, { e: 'üè´', n: 'school' }, { e: 'üè•', n: 'hospital' },
    { e: '‚õ™', n: 'church' }, { e: 'üèõÔ∏è', n: 'classical building' }, { e: 'üìç', n: 'location pin' }, { e: 'üöó', n: 'car' },
    { e: '‚úàÔ∏è', n: 'airplane travel' }, { e: 'üåé', n: 'earth globe' }, { e: 'üè™', n: 'store shop' }, { e: 'üÖøÔ∏è', n: 'parking' },
  ]},
  { cat: 'Nature', emojis: [
    { e: 'üåü', n: 'glowing star' }, { e: '‚òÄÔ∏è', n: 'sun' }, { e: 'üåô', n: 'moon' }, { e: 'üåà', n: 'rainbow' },
    { e: 'üî•', n: 'fire hot' }, { e: 'üíß', n: 'water drop' }, { e: '‚ùÑÔ∏è', n: 'snowflake cold' }, { e: 'üå∫', n: 'flower' },
    { e: 'üå≤', n: 'tree pine' }, { e: 'üçÄ', n: 'clover luck' }, { e: 'üêæ', n: 'paw prints animal' }, { e: 'ü¶ã', n: 'butterfly' },
  ]},
  { cat: 'Arrows & Numbers', emojis: [
    { e: '‚û°Ô∏è', n: 'right arrow' }, { e: '‚¨ÖÔ∏è', n: 'left arrow' }, { e: '‚¨ÜÔ∏è', n: 'up arrow' }, { e: '‚¨áÔ∏è', n: 'down arrow' },
    { e: '‚Ü©Ô∏è', n: 'return back' }, { e: 'üîÑ', n: 'refresh cycle' }, { e: '‚ë†', n: 'one 1' }, { e: '‚ë°', n: 'two 2' },
    { e: '‚ë¢', n: 'three 3' }, { e: '‚ë£', n: 'four 4' }, { e: '‚ë§', n: 'five 5' }, { e: '‚í∂', n: 'letter a' },
    { e: '‚í∑', n: 'letter b' }, { e: '‚í∏', n: 'letter c' }, { e: '‚Ñ¢', n: 'trademark' }, { e: '¬©', n: 'copyright' },
  ]},
];
let lastFocusedLine = 'line1';
document.addEventListener('focusin', e => { if (e.target.id && e.target.id.match(/^line[1-4]$/)) lastFocusedLine = e.target.id; });

function toggleEmojiPanel() {
  const panel = document.getElementById('emojiPanel'), btn = document.getElementById('emojiToggle');
  const show = !panel.classList.contains('visible');
  panel.classList.toggle('visible', show); btn.classList.toggle('active', show);
  if (show) { renderEmojiPanel(); document.getElementById('emojiSearch').value = ''; document.getElementById('emojiSearch').focus(); }
}
function renderEmojiPanel(filter) {
  const scroll = document.getElementById('emojiScroll');
  const q = (filter || '').toLowerCase().trim();
  let html = '';
  EMOJI_DATA.forEach(cat => {
    const filtered = q ? cat.emojis.filter(em => em.n.includes(q) || em.e === q) : cat.emojis;
    if (!filtered.length) return;
    html += '<div class="emoji-category"><div class="emoji-category-label">' + cat.cat + '</div><div class="emoji-grid">';
    filtered.forEach(em => { html += '<button class="emoji-btn" onclick="insertEmoji(\'' + em.e + '\')" title="' + em.n + '">' + em.e + '</button>'; });
    html += '</div></div>';
  });
  if (!html) html = '<div style="padding:12px;text-align:center;font-size:12px;color:var(--text-muted)">No matches</div>';
  scroll.innerHTML = html;
}
function filterEmojis() { renderEmojiPanel(document.getElementById('emojiSearch').value); }
function insertEmoji(emoji) {
  const input = document.getElementById(lastFocusedLine);
  const start = input.selectionStart || input.value.length, end = input.selectionEnd || start;
  input.value = input.value.slice(0, start) + emoji + input.value.slice(end);
  input.focus(); const pos = start + emoji.length; input.setSelectionRange(pos, pos); updatePreview();
}
document.addEventListener('click', e => {
  const panel = document.getElementById('emojiPanel'), btn = document.getElementById('emojiToggle');
  if (panel && panel.classList.contains('visible') && !panel.contains(e.target) && e.target !== btn && !btn.contains(e.target)) {
    panel.classList.remove('visible'); btn.classList.remove('active');
  }
});

// ========== RENDERING HELPERS ==========
function renderLineHtml(lineObj, escaped) {
  const parsed = parseLine(lineObj.text);
  const txt = escaped ? (t => escapeHtml(t)) : (t => t);
  const fs = lineObj.fontSize || 11;
  if (parsed.type === 'split') return '<div class="preview-line align-split" style="font-size:' + fs + 'px"><span>' + txt(parsed.left) + '</span><span>' + txt(parsed.right) + '</span></div>';
  if (parsed.type === 'fill') return '<div class="preview-line fill-line" style="font-size:' + fs + 'px"><span class="fill-label">' + txt(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + txt(parsed.trailing) + '</span>' : '') + '</div>';
  return '<div class="preview-line align-' + lineObj.align + '" style="font-size:' + fs + 'px">' + txt(parsed.text) + '</div>';
}
function renderPrintLineHtml(lineObj) {
  const parsed = parseLine(lineObj.text);
  const fs = lineObj.fontSize || 11;
  if (parsed.type === 'split') return '<div class="print-line align-split" style="font-size:' + fs + 'px"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
  if (parsed.type === 'fill') return '<div class="print-line fill-line" style="font-size:' + fs + 'px"><span class="fill-label">' + escapeHtml(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + escapeHtml(parsed.trailing) + '</span>' : '') + '</div>';
  return '<div class="print-line align-' + lineObj.align + '" style="font-size:' + fs + 'px">' + escapeHtml(parsed.text) + '</div>';
}
function renderMiniPreview(lines) {
  return lines.map(l => {
    const parsed = parseLine(l.text);
    const fs = Math.min(l.fontSize || 11, 10);
    if (parsed.type === 'split') return '<div class="preview-line align-split" style="font-size:' + fs + 'px"><span>' + escapeHtml(parsed.left) + '</span><span>' + escapeHtml(parsed.right) + '</span></div>';
    if (parsed.type === 'fill') return '<div class="preview-line fill-line" style="font-size:' + fs + 'px"><span class="fill-label">' + escapeHtml(parsed.label) + '</span><span class="fill-rule"></span>' + (parsed.trailing ? '<span class="fill-label">' + escapeHtml(parsed.trailing) + '</span>' : '') + '</div>';
    return '<div class="preview-line align-' + l.align + '" style="font-size:' + fs + 'px">' + escapeHtml(parsed.text) + '</div>';
  }).join('');
}

// ========== PREVIEW ==========
function isComposeDirty() {
  if (!hasAnyInput()) return false;
  if (!editingTextId) return true; // New unsaved text with content
  const saved = savedTexts.find(s => s.id === editingTextId);
  if (!saved) return true;
  const currentSerialized = serializeLines(getLines());
  return saved.text !== currentSerialized || (saved.alignV || 'center') !== alignV;
}

function updateDirtyIndicator() {
  const btn = document.getElementById('saveTextBtn');
  btn.style.display = isComposeDirty() ? '' : 'none';
}

function updatePreview() {
  const lines = getLines();
  const preview = document.getElementById('previewLabel');
  const shId = previewSheetId || activeSheetId;
  const sh = sheets[shId];
  if (!sh) return;
  const spec = getSpec(sh.labelType);
  document.getElementById('previewDimensions').textContent = spec.sizeDisplay + ' ‚Äî Avery ' + sh.labelType;
  document.getElementById('composeTypeChip').textContent = 'Avery ' + sh.labelType + ' ¬∑ ' + spec.sizeDisplay;

  const maxW = 240, maxH = 130;
  const scale = Math.min(maxW / spec.labelW, maxH / spec.labelH);
  const pw = Math.round(spec.labelW * scale), ph = Math.round(spec.labelH * scale);
  preview.style.width = pw + 'px'; preview.style.height = ph + 'px';

  if (!lines.length) {
    preview.className = 'preview-label empty-preview';
    preview.style.justifyContent = 'center'; preview.style.alignItems = 'center';
    preview.innerHTML = '<span>Type above to preview</span>';
    updateDirtyIndicator();
    return;
  }
  preview.className = 'preview-label';
  preview.style.justifyContent = getFlexAlign(alignV); preview.style.alignItems = 'stretch';
  preview.innerHTML = lines.map(l => renderLineHtml(l, true)).join('');
  updateDirtyIndicator();
}

function buildPreviewSheetSelect() {
  const sel = document.getElementById('previewSheetSelect');
  const ids = Object.keys(sheets).sort((a,b) => (sheets[a].createdAt||0) - (sheets[b].createdAt||0));
  sel.innerHTML = ids.map(id => {
    const s = sheets[id];
    return '<option value="' + id + '"' + (id === (previewSheetId || activeSheetId) ? ' selected' : '') + '>' + escapeHtml(s.name) + ' (' + getSpec(s.labelType).name.split(' /')[0] + ')</option>';
  }).join('');
  previewSheetId = sel.value || activeSheetId;
}
function onPreviewSheetChange() {
  previewSheetId = document.getElementById('previewSheetSelect').value;
  updatePreview();
}

// ========== SAVED TEXTS ==========
function loadSavedTexts() { try { const s = localStorage.getItem(TEXTS_KEY); if (s) savedTexts = JSON.parse(s); } catch(e){} }
function saveSavedTexts() { try { localStorage.setItem(TEXTS_KEY, JSON.stringify(savedTexts)); } catch(e){} }

function renderSavedTexts() {
  const list = document.getElementById('savedTextsList');
  document.getElementById('savedTextsCount').textContent = savedTexts.length ? savedTexts.length + ' saved' : '';
  if (!savedTexts.length) {
    list.innerHTML = '<div class="saved-texts-empty"><span class="icon">üìí</span>No saved texts yet.<br>Compose a label and click Save Text.</div>' +
      '<button class="new-text-card" onclick="startNewText()">+ New Text</button>';
    return;
  }
  const sorted = [...savedTexts].sort((a, b) => a.name.localeCompare(b.name));
  list.innerHTML = sorted.map(st => {
    const lines = deserializeLines(st.text);
    const previewHtml = renderMiniPreview(lines);
    return '<div class="saved-text-card" onclick="loadSavedText(\'' + st.id + '\')">' +
      '<div class="saved-text-card-header">' +
        '<span class="saved-text-card-name">' + escapeHtml(st.name) + '</span>' +
        '<span class="saved-text-card-actions">' +
          '<button class="st-action-btn edit" onclick="event.stopPropagation();editSavedText(\'' + st.id + '\')" title="Edit">‚úèÔ∏è</button>' +
          '<button class="st-action-btn" onclick="event.stopPropagation();deleteSavedText(\'' + st.id + '\')" title="Delete">‚úï</button>' +
        '</span>' +
      '</div>' +
      '<div class="saved-text-card-preview">' + previewHtml + '</div>' +
    '</div>';
  }).join('');
  list.innerHTML += '<button class="new-text-card" onclick="startNewText()">+ New Text</button>';
}

function loadSavedText(id) {
  const s = savedTexts.find(x => x.id === id); if (!s) return;
  // Set editing mode BEFORE loading inputs so updateDirtyIndicator
  // correctly compares against the saved version instead of treating
  // populated inputs as new unsaved content
  editingTextId = id;
  const lines = deserializeLines(s.text);
  loadLinesIntoInputs(lines);
  // Restore vertical alignment
  setAlignV(s.alignV || 'center');
  const indicator = document.getElementById('editingIndicator');
  indicator.style.display = 'flex';
  indicator.className = 'editing-indicator';
  indicator.innerHTML = '<span>Editing: <strong>' + escapeHtml(s.name) + '</strong></span><button class="cancel-edit" onclick="cancelEdit()">Cancel</button>';
  showAddToSheetButton(id);
}

function editSavedText(id) {
  loadSavedText(id); // Same as clicking now
  if (currentTab !== 'texts') doSwitchTab('texts');
}

function editTextFromSheet(id, evt) {
  // Don't navigate if double-click originated from a control (buttons, selects, inputs)
  if (evt && evt.target && evt.target.closest('button, select, input, .qty-btn, .assigned-text-remove, .assigned-text-controls')) return;
  // If already editing this text, just switch tabs
  if (editingTextId === id) {
    previewSheetId = activeSheetId;
    switchTab('texts');
    return;
  }
  // Check for unsaved changes before loading a different text
  if (isComposeDirty()) {
    showConfirm(
      editingTextId
        ? 'You have unsaved changes to "' + (savedTexts.find(s => s.id === editingTextId)?.name || 'text') + '". Discard them?'
        : 'You have unsaved text in the compose area. Discard it?',
      { title: '‚ö†Ô∏è Unsaved Changes', okText: 'Discard', cancelText: 'Keep Editing', danger: true }
    ).then(ok => {
      if (!ok) return;
      doEditTextFromSheet(id);
    });
    return;
  }
  doEditTextFromSheet(id);
}

function doEditTextFromSheet(id) {
  // Set the preview sheet to the current active sheet so dimensions match
  previewSheetId = activeSheetId;
  loadSavedText(id);
  doSwitchTab('texts');
  // Ensure the preview dropdown reflects the active sheet
  const sel = document.getElementById('previewSheetSelect');
  if (sel) sel.value = activeSheetId;
  updatePreview();
  // Scroll the saved text card into view in the right panel
  setTimeout(() => {
    const cards = document.querySelectorAll('.saved-text-card');
    cards.forEach(card => {
      if (card.onclick && card.onclick.toString().includes(id)) {
        card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        card.style.outline = '2px solid var(--accent)';
        setTimeout(() => { card.style.outline = ''; }, 1500);
      }
    });
  }, 100);
}

function cancelEdit() {
  editingTextId = null;
  clearInputs();
  hideAddToSheetButton();
  setStatus('', '');
}

function startNewText() {
  if (isComposeDirty()) {
    showConfirm(
      editingTextId
        ? 'You have unsaved changes to "' + (savedTexts.find(s => s.id === editingTextId)?.name || 'text') + '". Discard them?'
        : 'You have unsaved text in the compose area. Discard it?',
      { title: '‚ö†Ô∏è Unsaved Changes', okText: 'Discard', cancelText: 'Keep Editing', danger: true }
    ).then(ok => {
      if (!ok) return;
      doStartNewText();
    });
    return;
  }
  doStartNewText();
}

function doStartNewText() {
  editingTextId = null;
  clearInputs();
  hideAddToSheetButton();
  document.getElementById('editingIndicator').style.display = 'none';
  setAlignV('center');
  document.getElementById('line1').focus();
  setStatus('Ready for a new text', 'info');
}

function saveCurrentText() {
  const lines = getLines();
  if (!lines.length) { setStatus('Enter text first', 'warning'); return; }

  if (editingTextId) {
    // Update existing
    const existing = savedTexts.find(s => s.id === editingTextId);
    if (existing) {
      existing.text = serializeLines(lines);
      existing.alignV = alignV;
      saveSavedTexts(); renderSavedTexts();
      updateDirtyIndicator();
      setStatus('Updated "' + existing.name + '"', 'success');
      // Stay in editing mode so they can keep tweaking
    }
    return;
  }

  // New save - show name input
  const row = document.getElementById('saveNameRow');
  if (row.style.display === 'none' || !row.innerHTML) {
    row.style.display = 'block';
    row.innerHTML = '<div class="save-name-row">' +
      '<input type="text" id="saveNameInput" placeholder="Name this text (e.g., Aria, Return Address)" maxlength="40">' +
      '<button class="btn btn-primary btn-sm" onclick="confirmSaveText()">Save</button>' +
      '<button class="btn btn-secondary btn-sm" onclick="cancelSaveName()">‚úï</button>' +
    '</div>';
    document.getElementById('saveNameInput').focus();
    document.getElementById('saveNameInput').addEventListener('keydown', e => {
      if (e.key === 'Enter') confirmSaveText();
      if (e.key === 'Escape') cancelSaveName();
    });
  }
}

function confirmSaveText() {
  const nameInput = document.getElementById('saveNameInput');
  if (!nameInput) return;
  const name = nameInput.value.trim();
  if (!name) { nameInput.style.borderColor = 'var(--danger)'; nameInput.focus(); return; }
  const lines = getLines();
  if (!lines.length) { setStatus('Enter text first', 'warning'); return; }
  const id = generateId('st');
  savedTexts.push({ id, name, text: serializeLines(lines), alignV: alignV });
  saveSavedTexts(); renderSavedTexts();
  cancelSaveName();
  // Switch into editing mode for the newly saved text
  editingTextId = id;
  updateDirtyIndicator();
  const indicator = document.getElementById('editingIndicator');
  indicator.style.display = 'flex';
  indicator.className = 'editing-indicator';
  indicator.innerHTML = '<span>Editing: <strong>' + escapeHtml(name) + '</strong></span><button class="cancel-edit" onclick="cancelEdit()">Cancel</button>';
  setStatus('Saved "' + name + '"', 'success');
  showAddToSheetButton(id);
  updateTabMeta();
}

function cancelSaveName() {
  const row = document.getElementById('saveNameRow');
  row.style.display = 'none';
  row.innerHTML = '';
}

async function deleteSavedText(id) {
  const s = savedTexts.find(x => x.id === id); if (!s) return;
  const ok = await showConfirm('Delete saved text "' + s.name + '"?', { title: 'üóëÔ∏è Delete Saved Text', okText: 'Delete', danger: true });
  if (!ok) return;
  savedTexts = savedTexts.filter(x => x.id !== id);
  if (editingTextId === id) cancelEdit();
  // Remove from all sheets
  for (const sh of Object.values(sheets)) {
    if (sh.texts && sh.texts[id]) delete sh.texts[id];
  }
  saveSavedTexts(); saveSheets(); renderSavedTexts();
  setStatus('Deleted "' + s.name + '"', 'info');
  updateTabMeta();
}

// ========== ADD TO SHEET (from texts tab) ==========
function showAddToSheetButton(textId) {
  const row = document.getElementById('addToSheetRow');
  const sh = getActiveSheet();
  const rem = getRemaining();
  if (rem > 0 && activeSheetId) {
    // Check if already on the active sheet
    const already = sh.texts && sh.texts[textId];
    if (already) {
      row.style.display = 'block';
      row.innerHTML = '<div class="queue-nudge" style="margin-top:8px"><span class="queue-nudge-text">On "' + escapeHtml(sh.name) + '"</span>' +
        '<button class="queue-nudge-btn" onclick="switchTab(\'sheets\')">View Sheet ‚Üí</button></div>';
    } else {
      row.style.display = 'block';
      row.innerHTML = '<div class="queue-nudge" style="margin-top:8px"><span class="queue-nudge-text">' + rem + ' spots on "' + escapeHtml(sh.name) + '"</span>' +
        '<button class="queue-nudge-btn" onclick="addTextToActiveSheet(\'' + textId + '\')">Add to Sheet ‚Üí</button></div>';
    }
  } else {
    row.style.display = 'none';
  }
}
function hideAddToSheetButton() {
  document.getElementById('addToSheetRow').style.display = 'none';
}

function addTextToActiveSheet(textId) {
  const sh = getActiveSheet();
  if (!sh.texts) sh.texts = {};
  if (sh.texts[textId]) {
    // Already exists, just go to sheet
    switchTab('sheets');
    return;
  }
  sh.texts[textId] = { qty: 0, placement: 'next' };
  saveSheets();
  setStatus('Added to "' + sh.name + '" ‚Äî go to Sheets to set quantity', 'success');
  showAddToSheetButton(textId);
  updateTabMeta();
}

// ========== SHEET PERSISTENCE ==========
function loadSheets() {
  try { const s = localStorage.getItem(SHEETS_KEY); if (s) sheets = JSON.parse(s); activeSheetId = localStorage.getItem(ACTIVE_KEY); } catch(e){}
  if (!Object.keys(sheets).length) {
    try {
      const old = localStorage.getItem('avery5160_sheets');
      if (old) { const oldSheets = JSON.parse(old); for (const [id, sh] of Object.entries(oldSheets)) { sheets[id] = { ...sh, labelType: '5160' }; } activeSheetId = localStorage.getItem('avery5160_active'); }
    } catch(e){}
  }
  // Migration: ensure all sheets have texts property, labelType, and placement on text entries
  for (const sh of Object.values(sheets)) {
    if (!sh.labelType) sh.labelType = '5160';
    if (!sh.texts) sh.texts = {};
    // v10: ensure all text entries have placement
    for (const entry of Object.values(sh.texts)) {
      if (!entry.placement) entry.placement = 'next';
    }
  }
  if (activeSheetId && sheets[activeSheetId]) return;
  if (Object.keys(sheets).length) { activeSheetId = Object.keys(sheets)[0]; saveSheets(); }
}
function saveSheets() { try { localStorage.setItem(SHEETS_KEY, JSON.stringify(sheets)); localStorage.setItem(ACTIVE_KEY, activeSheetId); } catch(e){} }

// ========== SHEETS TAB ==========
function buildSheetCards() {
  const container = document.getElementById('sheetCardsList');
  const ids = Object.keys(sheets).sort((a,b) => (sheets[a].createdAt||0) - (sheets[b].createdAt||0));

  if (!ids.length) {
    container.innerHTML = '<div class="no-sheet-selected"><span class="icon">üìÑ</span>No sheets yet. Create one to get started.</div>';
    return;
  }

  container.innerHTML = ids.map(id => {
    const s = sheets[id], spec = getSpec(s.labelType), total = spec.cols * spec.rows;
    const printed = (s.printed || []).length, rem = total - printed;
    const pct = rem / total;
    const isActive = id === activeSheetId;
    const assigned = getAssignedCount(s);
    const r = 18, c = 2 * Math.PI * r;
    const strokePct = rem / total;
    const color = pct === 0 ? 'var(--danger)' : pct <= 0.2 ? 'var(--warning-text)' : 'var(--success-text)';
    const textCount = s.texts ? Object.keys(s.texts).length : 0;

    return '<div class="sheet-card' + (isActive ? ' active' : '') + '" onclick="selectSheet(\'' + id + '\')">' +
      '<div class="sheet-card-info">' +
        '<div class="sheet-card-name">' + escapeHtml(s.name) + '</div>' +
        '<div class="sheet-card-detail"><strong>' + spec.name.split(' /')[0] + '</strong> ¬∑ ' + spec.desc + ' ¬∑ ' + spec.sizeDisplay + '</div>' +
        (textCount ? '<div class="sheet-card-detail">' + textCount + ' text' + (textCount!==1?'s':'') + (assigned ? ' ¬∑ ' + assigned + ' queued' : '') + '</div>' : '') +
      '</div>' +
      '<div class="sheet-card-progress">' +
        '<svg width="48" height="48" viewBox="0 0 48 48">' +
          '<circle cx="24" cy="24" r="' + r + '" fill="none" stroke="var(--border)" stroke-width="4"/>' +
          '<circle cx="24" cy="24" r="' + r + '" fill="none" stroke="' + color + '" stroke-width="4" stroke-dasharray="' + c + '" stroke-dashoffset="' + (c * (1 - strokePct)) + '" stroke-linecap="round"/>' +
        '</svg>' +
        '<span class="progress-text">' + rem + '/' + total + '</span>' +
      '</div>' +
      '<div class="sheet-card-actions">' +
        '<button class="sheet-card-action" onclick="event.stopPropagation();renameSheet(\'' + id + '\')" title="Rename">‚úèÔ∏è</button>' +
        (printed > 0 ? '<button class="sheet-card-action" onclick="event.stopPropagation();resetSheet(\'' + id + '\')" title="Reset all labels">üîÑ</button>' : '') +
        '<button class="sheet-card-action danger" onclick="event.stopPropagation();deleteSheet(\'' + id + '\')" title="Delete">üóëÔ∏è</button>' +
      '</div>' +
    '</div>';
  }).join('');

  container.innerHTML += '<button class="new-sheet-card" onclick="showNewSheetModal()">+ New Sheet</button>';
}

function selectSheet(id) {
  if (!sheets[id]) return;
  activeSheetId = id;
  saveSheets();
  buildSheetCards();
  buildSheetDetail();
  buildAssignedTexts();
  updateTabMeta();
}

function buildSheetDetail() {
  const area = document.getElementById('sheetDetailArea');
  if (!activeSheetId) {
    area.innerHTML = '<div class="no-sheet-selected"><span class="icon">üëà</span>Select a sheet to see its detail</div>';
    return;
  }
  const sh = getActiveSheet();
  const spec = getActiveSpec();
  const { assignments, errors } = buildAssignments(sh);
  const mapHtml = buildSheetMapHtml(sh, assignments);
  const totalLabels = Object.values(assignments).reduce((s, arr) => s + arr.length, 0);
  const hasErrors = errors.length > 0;

  let printHtml = '';
  if (totalLabels > 0) {
    printHtml = '<div class="sheet-print-actions">' +
      '<button class="btn btn-primary btn-full" onclick="printLabels()"' + (hasErrors ? ' disabled' : '') + '>üñ®Ô∏è Print ' + totalLabels + ' Label' + (totalLabels !== 1 ? 's' : '') + '</button>' +
      '<div style="margin-top:8px;font-size:12px;color:var(--text-faint);line-height:1.5">Set margins to <strong style="color:var(--text-muted)">None</strong> and uncheck <strong style="color:var(--text-muted)">Print headers and footers</strong></div>';
    if (hasErrors) {
      printHtml += '<div class="sheet-print-error">‚ö†Ô∏è Cannot print ‚Äî ';
      printHtml += errors.map(e => {
        const st = getSavedText(e.textId);
        return '"' + escapeHtml(st ? st.name : '?') + '": ' + e.message;
      }).join('; ');
      printHtml += '</div>';
    }
    printHtml += '</div>';
  }

  area.innerHTML = printHtml +
  '<div class="sheet-map-container">' +
    '<div class="sheet-map-header">' +
      '<span>' + escapeHtml(sh.name) + '</span>' +
      '<span style="font-family:var(--mono);font-size:13px;color:var(--text-muted)">Avery ' + sh.labelType + ' ¬∑ ' + spec.layoutDisplay + '</span>' +
    '</div>' +
    '<div class="sheet-map-sub" style="font-size:13px">' + spec.desc + ' ¬∑ ' + spec.sizeDisplay + '</div>' +
    mapHtml +
    buildRemainingBar(sh) +
    buildLegendHtml(true) +
    (lastPrintJob && lastPrintJob.sheetId === activeSheetId ? '<button class="btn btn-secondary btn-sm" onclick="undoLastPrint()" style="margin-top:12px;font-size:13px">‚Ü©Ô∏è Undo Last Print (' + lastPrintJob.indices.length + ' label' + (lastPrintJob.indices.length !== 1 ? 's' : '') + ')</button>' : '') +
  '</div>';
}

function buildAssignedTexts() {
  const area = document.getElementById('sheetAssignedArea');
  if (!activeSheetId) { area.innerHTML = ''; return; }
  const sh = getActiveSheet();
  area.innerHTML = buildAssignedTextsHtml(sh);
}

function buildAssignedTextsHtml(sh) {
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  const { assignments, errors } = buildAssignments(sh);
  const avail = getAvailableSpots(sh);
  const spec = getSpec(sh.labelType);
  const errorMap = {};
  errors.forEach(e => { errorMap[e.textId] = e.message; });

  let html = '<div class="assigned-texts-section">' +
    '<div class="assigned-texts-header">' +
      '<span class="assigned-texts-title">Assigned Texts</span>' +
      '<button class="btn btn-primary btn-sm" onclick="showAddTextPicker()">+ Add Text</button>' +
    '</div>' +
    '<div class="assigned-texts-list">';

  if (!textIds.length) {
    html += '<div class="assigned-texts-empty">üè∑Ô∏è No texts assigned yet. Click "Add Text" or go to the Texts tab to create one.</div>';
  } else {
    textIds.forEach((textId, idx) => {
      const st = getSavedText(textId);
      if (!st) return;
      const entry = sh.texts[textId];
      const qty = entry.qty || 0;
      const placement = entry.placement || 'next';
      const colorIdx = idx % TEXT_COLORS.length;
      const lines = deserializeLines(st.text);
      const previewHtml = renderMiniPreview(lines);
      const posCount = assignments[textId] ? assignments[textId].length : 0;
      const hasError = errorMap[textId];

      // Build placement options
      let placementHtml = '<select class="assigned-text-placement" onchange="setTextPlacement(\'' + textId + '\', this.value)">';
      placementHtml += '<option value="next"' + (placement === 'next' ? ' selected' : '') + '>Next Avail</option>';
      for (let c = 1; c <= spec.cols; c++) {
        const val = 'col:' + c;
        placementHtml += '<option value="' + val + '"' + (placement === val ? ' selected' : '') + '>Col ' + c + '</option>';
      }
      placementHtml += '</select>';

      html += '<div class="assigned-text-row' + (hasError ? ' has-error' : '') + '" ondblclick="editTextFromSheet(\'' + textId + '\', event)" title="Double-click to edit">' +
        '<div class="assigned-text-color" style="background:' + TEXT_COLORS[colorIdx] + '"></div>' +
        '<div class="assigned-text-preview">' + previewHtml + '</div>' +
        '<div class="assigned-text-info">' +
          '<div class="assigned-text-name">' + escapeHtml(st.name) + '</div>' +
          '<div class="assigned-text-spots">' + (hasError ? '‚ö†Ô∏è ' + escapeHtml(hasError) : posCount + ' position' + (posCount!==1?'s':'') + ' assigned') + '</div>' +
        '</div>' +
        '<div class="assigned-text-controls">' +
          placementHtml +
          '<div class="assigned-text-qty">' +
            '<button class="qty-btn" onclick="adjustAssignedQty(\'' + textId + '\', -1)">‚àí</button>' +
            '<span class="qty-val">' + qty + '</span>' +
            '<button class="qty-btn" onclick="adjustAssignedQty(\'' + textId + '\', 1)">+</button>' +
          '</div>' +
        '</div>' +
        '<button class="assigned-text-remove" onclick="removeTextFromSheet(\'' + textId + '\')" title="Remove">‚úï</button>' +
      '</div>';
    });
  }

  html += '</div>';
  if (avail > 0) {
    html += '<div style="margin-top:8px;font-size:13px;color:var(--text-muted);font-weight:600">' + avail + ' spot' + (avail!==1?'s':'') + ' still available</div>';
  }
  html += '</div>';
  return html;
}

function setTextPlacement(textId, value) {
  const sh = getActiveSheet();
  if (!sh.texts || !sh.texts[textId]) return;
  sh.texts[textId].placement = value;
  saveSheets();
  buildAssignedTexts();
  buildSheetDetail();
  buildSheetCards();
}

function adjustAssignedQty(textId, delta) {
  const sh = getActiveSheet();
  if (!sh.texts || !sh.texts[textId]) return;
  const current = sh.texts[textId].qty || 0;
  const maxAdd = getAvailableSpots(sh);
  let newQty = current + delta;
  if (newQty < 0) newQty = 0;
  if (delta > 0 && maxAdd <= 0) return; // no room
  if (newQty > current + maxAdd) newQty = current + maxAdd;
  sh.texts[textId].qty = newQty;
  saveSheets();
  buildAssignedTexts();
  buildSheetDetail();
  buildSheetCards();
  updateTabMeta();
}

async function removeTextFromSheet(textId) {
  const sh = getActiveSheet();
  const st = getSavedText(textId);
  const name = st ? st.name : 'this text';
  const ok = await showConfirm('Remove "' + name + '" from this sheet?', { title: 'Remove Text', okText: 'Remove', danger: true });
  if (!ok) return;
  if (sh.texts) delete sh.texts[textId];
  saveSheets();
  buildAssignedTexts();
  buildSheetDetail();
  buildSheetCards();
  updateTabMeta();
}

function showAddTextPicker() {
  const sh = getActiveSheet();
  const existingIds = new Set(sh.texts ? Object.keys(sh.texts) : []);
  const available = savedTexts.filter(st => !existingIds.has(st.id));

  if (!savedTexts.length) {
    showAlert('No saved texts yet. Go to the Texts tab to create one first.', { title: 'No Texts Available' });
    return;
  }
  if (!available.length) {
    showAlert('All saved texts are already assigned to this sheet.', { title: 'All Assigned' });
    return;
  }

  const modal = document.getElementById('addTextModal');
  document.getElementById('addTextModalTitle').textContent = 'üè∑Ô∏è Add Text to "' + sh.name + '"';
  document.getElementById('addTextModalMsg').textContent = 'Choose a text to assign:';

  const list = document.getElementById('addTextPickerList');
  list.innerHTML = available.sort((a,b) => a.name.localeCompare(b.name)).map(st => {
    const lines = deserializeLines(st.text);
    const previewHtml = renderMiniPreview(lines);
    return '<div class="saved-text-card" onclick="pickTextForSheet(\'' + st.id + '\')" style="cursor:pointer">' +
      '<div class="saved-text-card-header"><span class="saved-text-card-name">' + escapeHtml(st.name) + '</span></div>' +
      '<div class="saved-text-card-preview">' + previewHtml + '</div>' +
    '</div>';
  }).join('');

  modal.classList.add('visible');
}

function pickTextForSheet(textId) {
  const sh = getActiveSheet();
  if (!sh.texts) sh.texts = {};
  sh.texts[textId] = { qty: 0, placement: 'next' };
  saveSheets();
  closeModal('addTextModal');
  buildAssignedTexts();
  buildSheetDetail();
  buildSheetCards();
  updateTabMeta();
}

// ========== SHEET MAP RENDERING ==========
function buildSheetMapHtml(sh, assignmentsObj) {
  const spec = getSpec(sh.labelType);
  const total = spec.cols * spec.rows;
  const printed = new Set(sh.printed || []);
  const assignments = assignmentsObj || buildAssignments(sh).assignments;

  // Build reverse map: index -> { textId, colorIdx }
  const indexMap = {};
  const textIds = sh.texts ? Object.keys(sh.texts) : [];
  textIds.forEach((textId, colorIdx) => {
    const indices = assignments[textId] || [];
    indices.forEach(idx => { indexMap[idx] = { textId, colorIdx: colorIdx % TEXT_COLORS.length }; });
  });

  const gridStyle = 'grid-template-columns: repeat(' + spec.cols + ', 1fr)';
  const cellFont = total > 40 ? 7 : total > 20 ? 8 : 9;
  const numFont = total > 40 ? 6 : 7;
  const showNum = total <= 80;

  let gridHtml = '<div class="label-grid" style="' + gridStyle + '">';
  for (let i = 0; i < total; i++) {
    const isPrinted = printed.has(i);
    const assignment = indexMap[i];
    let cls = 'label-cell';
    let extraStyle = '';
    if (isPrinted) cls += ' printed';
    else if (assignment) cls += ' cell-color-' + assignment.colorIdx;

    const ar = 'aspect-ratio: ' + spec.labelW + ' / ' + spec.labelH;
    const clickAttr = isPrinted ? ' onclick="toggleCellPrinted(' + i + ')" title="Click to mark as available"' : '';
    let inner = showNum ? '<span class="label-number" style="font-size:' + numFont + 'px">' + (i+1) + '</span>' : '';
    if (isPrinted) {
      inner += '<span class="printed-badge" style="font-size:' + numFont + 'px">‚úì</span>';
    } else if (assignment) {
      const st = getSavedText(assignment.textId);
      if (st) {
        const lines = deserializeLines(st.text);
        inner += '<span class="label-text" style="font-size:' + cellFont + 'px">' + escapeHtml(getFlatText(lines).substring(0, 20)) + '</span>';
      }
    } else if (total <= 30) {
      inner += '<span class="empty-state">avail</span>';
    }
    gridHtml += '<div class="' + cls + '" style="font-size:' + cellFont + 'px;' + ar + '"' + clickAttr + '>' + inner + '</div>';
  }
  gridHtml += '</div>';
  return gridHtml;
}

function buildRemainingBar(sh) {
  const total = getTotal(sh), printed = getPrinted(sh).length;
  const rem = total - printed;
  const pct = rem / total;
  const bannerClass = rem === 0 ? 'empty' : pct <= 0.2 ? 'low' : 'plenty';
  const assigned = getAssignedCount(sh);
  const unassigned = rem - assigned;

  return '<div class="remaining-bar ' + bannerClass + '">' +
    '<span class="count">' + rem + '</span> label' + (rem!==1?'s':'') + ' remaining' +
    (assigned > 0 ? ' <span style="font-size:12px;font-weight:500;opacity:0.8">(' + assigned + ' assigned, ' + Math.max(0,unassigned) + ' open)</span>' : '') +
  '</div>';
}

function buildLegendHtml(showAssigned) {
  let html = '<div class="legend">' +
    '<div class="legend-item"><div class="legend-swatch available"></div> Available</div>';
  if (showAssigned) {
    html += '<div class="legend-item"><div class="legend-swatch" style="background:' + TEXT_COLORS[0] + ';border-color:' + TEXT_COLORS[0] + '"></div> Assigned</div>';
  }
  html += '<div class="legend-item"><div class="legend-swatch printed"></div> Used</div></div>';
  return html;
}

// ========== CELL & SHEET RESET ==========
function toggleCellPrinted(idx) {
  const sh = getActiveSheet();
  if (!sh.printed) return;
  const pos = sh.printed.indexOf(idx);
  if (pos === -1) return; // not printed, nothing to do
  sh.printed.splice(pos, 1);
  saveSheets();
  buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
}

async function resetSheet(id) {
  const sh = sheets[id]; if (!sh) return;
  const printedCount = (sh.printed || []).length;
  if (printedCount === 0) {
    showAlert('No used labels to reset on "' + sh.name + '".', { title: 'Nothing to Reset' });
    return;
  }
  const ok = await showConfirm(
    'Reset "' + sh.name + '" to all labels available? This will unmark ' + printedCount + ' used position' + (printedCount !== 1 ? 's' : '') + ' and set all quantities to 0.\n\nThis is useful when you replace the physical sheet with a fresh one.',
    { title: 'üîÑ Reset Sheet', okText: 'Reset All', danger: true }
  );
  if (!ok) return;
  sh.printed = [];
  // Reset all text qtys to 0
  if (sh.texts) {
    for (const entry of Object.values(sh.texts)) { entry.qty = 0; }
  }
  saveSheets();
  lastPrintJob = null; // undo no longer relevant
  buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
  setStatus('"' + sh.name + '" reset ‚Äî all ' + getTotal(sh) + ' labels available', 'success');
}

// ========== SHEET MANAGEMENT ==========
function showNewSheetModal() {
  newSheetLabelType = '5160';
  document.getElementById('newSheetName').value = '';
  buildLabelTypeGrid();
  const modal = document.getElementById('newSheetModal');
  const title = document.getElementById('newSheetModalTitle');
  const cancelBtn = document.getElementById('newSheetCancelBtn');
  if (firstRunRequired) { title.textContent = 'üëã Welcome ‚Äî Create Your First Sheet'; cancelBtn.style.display = 'none'; }
  else { title.textContent = 'üìÑ New Label Sheet'; cancelBtn.style.display = ''; }
  modal.classList.add('visible');
  document.getElementById('newSheetName').focus();
}

function buildLabelTypeGrid() {
  const grid = document.getElementById('labelTypeGrid');
  grid.innerHTML = TYPE_ORDER.map(typeId => {
    const t = LABEL_TYPES[typeId], total = t.cols * t.rows;
    const sel = typeId === newSheetLabelType ? ' selected' : '';
    const miniCols = Math.min(t.cols, 4), miniRows = Math.min(t.rows, 5);
    const cellW = Math.max(4, Math.round(20 * t.labelW / Math.max(t.labelW, t.labelH)));
    const cellH = Math.max(3, Math.round(20 * t.labelH / Math.max(t.labelW, t.labelH)));
    let miniHtml = '<div class="ltc-mini-grid" style="grid-template-columns:repeat(' + miniCols + ',' + cellW + 'px)">';
    for (let i = 0; i < miniCols * miniRows; i++) miniHtml += '<div class="ltc-mini-cell" style="width:' + cellW + 'px;height:' + cellH + 'px"></div>';
    miniHtml += '</div>';
    if (t.rows > 5) miniHtml += '<div style="font-size:9px;color:var(--text-faint);margin-top:1px">+' + (t.rows-5) + ' more rows</div>';
    return '<div class="label-type-card' + sel + '" onclick="selectLabelType(\'' + typeId + '\')" data-type="' + typeId + '">' +
      '<div class="ltc-header"><span class="ltc-name">' + typeId + '</span><span class="ltc-count">' + total + '/sheet</span></div>' +
      '<div class="ltc-desc">' + t.desc + '</div>' +
      '<div class="ltc-dims">' + t.sizeDisplay + ' ‚Äî ' + t.layoutDisplay + '</div>' + miniHtml + '</div>';
  }).join('');
}

function selectLabelType(typeId) {
  newSheetLabelType = typeId;
  document.querySelectorAll('.label-type-card').forEach(c => c.classList.toggle('selected', c.dataset.type === typeId));
}

function createNewSheet() {
  const name = document.getElementById('newSheetName').value.trim();
  if (!name) { document.getElementById('newSheetName').style.borderColor = 'var(--danger)'; return; }
  const id = generateId();
  sheets[id] = { name, printed: [], labelType: newSheetLabelType, texts: {}, createdAt: Date.now() };
  activeSheetId = id; saveSheets();
  firstRunRequired = false;
  closeModal('newSheetModal');
  buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
}

async function renameSheet(id) {
  const sh = sheets[id]; if (!sh) return;
  const n = await showPrompt('Enter new name:', sh.name, { title: '‚úèÔ∏è Rename Sheet', placeholder: 'Sheet name' });
  if (n && n.trim()) { sh.name = n.trim(); saveSheets(); buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta(); }
}

async function deleteSheet(id) {
  const sh = sheets[id]; if (!sh) return;
  const isLast = Object.keys(sheets).length <= 1;
  const msg = isLast ? 'Delete "' + sh.name + '"? This is your only sheet.' : 'Delete "' + sh.name + '"?';
  const ok = await showConfirm(msg, { title: 'üóëÔ∏è Delete Sheet', okText: 'Delete', danger: true });
  if (!ok) return;
  delete sheets[id];
  if (Object.keys(sheets).length) {
    if (activeSheetId === id) activeSheetId = Object.keys(sheets)[0];
    saveSheets(); buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
  } else {
    activeSheetId = null; saveSheets();
    firstRunRequired = true; buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
    showNewSheetModal();
  }
}

function closeModal(id) {
  if (id === 'newSheetModal' && firstRunRequired) return;
  document.getElementById(id).classList.remove('visible');
}

// ========== UI UPDATES ==========
function setStatus(msg, type) {
  const el = document.getElementById('statusMsg');
  el.textContent = msg;
  el.className = 'status-msg' + (type ? ' ' + type : '');
}

// ========== PRINTING ==========
async function printLabels() {
  const sh = getActiveSheet();
  const spec = getActiveSpec();
  const { assignments, errors } = buildAssignments(sh);

  // Abort if any placement errors
  if (errors.length > 0) {
    const msgs = errors.map(e => {
      const st = getSavedText(e.textId);
      return '"' + (st ? st.name : '?') + '": ' + e.message;
    }).join('\n');
    showAlert('Cannot print ‚Äî placement errors:\n\n' + msgs, { title: '‚ö†Ô∏è Print Aborted' });
    return;
  }

  const textIds = sh.texts ? Object.keys(sh.texts).filter(id => (sh.texts[id].qty || 0) > 0) : [];
  if (!textIds.length) return;

  // Build print map
  const printMap = {};
  textIds.forEach(textId => {
    const st = getSavedText(textId);
    if (!st) return;
    const lines = deserializeLines(st.text);
    const indices = assignments[textId] || [];
    indices.forEach(idx => { printMap[idx] = { lines, alignV: st.alignV || 'center' }; });
  });

  if (!Object.keys(printMap).length) return;

  const totalLabels = Object.keys(printMap).length;
  const printSheet = document.getElementById('printSheet');
  let html = '';
  for (let r = 0; r < spec.rows; r++) {
    for (let c = 0; c < spec.cols; c++) {
      const idx = r * spec.cols + c;
      const top = spec.topMargin + r * (spec.labelH + spec.vGutter);
      const left = spec.leftMargin + c * (spec.labelW + spec.hGutter);
      const p = printMap[idx];
      if (p) {
        const linesHtml = p.lines.map(l => renderPrintLineHtml(l)).join('');
        html += '<div class="print-label" style="top:' + top + 'in;left:' + left + 'in;width:' + spec.labelW + 'in;height:' + spec.labelH + 'in;padding:0.08in 0.12in;justify-content:' + getFlexAlign(p.alignV) + ';">' + linesHtml + '</div>';
      }
    }
  }
  printSheet.innerHTML = html;

  // Use an iframe for printing ‚Äî guarantees a clean document with no
  // parent DOM elements that Safari might include in pagination.
  const iframe = document.createElement('iframe');
  iframe.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;border:none;visibility:hidden;';
  document.body.appendChild(iframe);

  const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write('<!DOCTYPE html><html><head><style>' +
    '@page { size: letter; margin: 0; }' +
    'html, body { margin:0; padding:0; width:8.5in; height:11in; overflow:hidden; }' +
    '.print-sheet { width:8.5in; height:11in; margin:0; padding:0; position:relative; overflow:hidden; box-sizing:border-box; }' +
    '.print-label { position:absolute; overflow:hidden; font-family:Arial,sans-serif; line-height:1.3; color:#000; display:flex; flex-direction:column; box-sizing:border-box; }' +
    '.print-line { width:100%; display:flex; white-space:nowrap; overflow:hidden; }' +
    '.print-line.align-left { justify-content:flex-start; text-align:left; }' +
    '.print-line.align-center { justify-content:center; text-align:center; }' +
    '.print-line.align-right { justify-content:flex-end; text-align:right; }' +
    '.print-line.align-split { justify-content:space-between; text-align:left; }' +
    '.print-line.fill-line { display:flex; align-items:flex-end; gap:3px; }' +
    '.print-line.fill-line .fill-label { white-space:nowrap; flex-shrink:0; }' +
    '.print-line.fill-line .fill-rule { flex:1; border-bottom:1px solid #000; min-width:0.25in; margin-bottom:1px; }' +
  '</style></head><body>' +
    '<div class="print-sheet">' + html + '</div>' +
  '</body></html>');
  iframeDoc.close();

  // Wait for iframe to render, then print it
  iframe.contentWindow.focus();
  iframe.contentWindow.print();

  // Clean up iframe after a short delay
  setTimeout(() => { document.body.removeChild(iframe); }, 1000);
  printSheet.innerHTML = '';

  // After print dialog closes, ask user to confirm
  const confirmed = await showConfirm(
    totalLabels + ' label' + (totalLabels !== 1 ? 's' : '') + ' were sent to the printer. Did the print complete successfully?',
    { title: 'üñ®Ô∏è Confirm Print', okText: 'Yes, printed OK', cancelText: 'No, discard' }
  );

  if (confirmed) {
    // Mark positions as printed, reset qtys, keep associations
    sh.printed = [...new Set([...(sh.printed||[]), ...Object.keys(printMap).map(Number)])];
    for (const textId of textIds) {
      if (sh.texts[textId]) sh.texts[textId].qty = 0;
    }
    saveSheets();
    printSheet.innerHTML = '';

    // Stash for undo
    lastPrintJob = { sheetId: activeSheetId, indices: Object.keys(printMap).map(Number), textQtys: {} };
    textIds.forEach(id => { lastPrintJob.textQtys[id] = (assignments[id] || []).length; });

    const rem = getRemaining();
    buildSheetCards();
    buildSheetDetail();
    buildAssignedTexts();
    updateTabMeta();
    if (rem > 0) {
      setStatus('Printed! ' + rem + ' spots left on "' + sh.name + '"', 'success');
    } else {
      showAlert('"' + sh.name + '" is now full. Select or create another sheet.', { title: '‚úÖ Sheet Complete' });
    }
  } else {
    // User says print didn't happen ‚Äî leave everything as-is
    printSheet.innerHTML = '';
    setStatus('Print cancelled ‚Äî no labels were marked as used', 'warning');
  }
}

async function undoLastPrint() {
  if (!lastPrintJob) return;
  const sh = sheets[lastPrintJob.sheetId];
  if (!sh) { lastPrintJob = null; return; }
  const ok = await showConfirm(
    'Undo the last print on "' + sh.name + '"? This will unmark ' + lastPrintJob.indices.length + ' position' + (lastPrintJob.indices.length !== 1 ? 's' : '') + ' as used and restore the quantities.',
    { title: '‚Ü©Ô∏è Undo Last Print', okText: 'Undo', cancelText: 'Keep' }
  );
  if (!ok) return;
  // Remove printed indices
  const undoSet = new Set(lastPrintJob.indices);
  sh.printed = (sh.printed || []).filter(i => !undoSet.has(i));
  // Restore text qtys
  if (lastPrintJob.textQtys && sh.texts) {
    for (const [textId, qty] of Object.entries(lastPrintJob.textQtys)) {
      if (sh.texts[textId]) sh.texts[textId].qty = qty;
    }
  }
  saveSheets();
  const undoneSheetId = lastPrintJob.sheetId;
  const undoneName = sh.name;
  lastPrintJob = null;
  // Refresh if we're looking at that sheet
  if (activeSheetId === undoneSheetId) {
    buildSheetCards(); buildSheetDetail(); buildAssignedTexts(); updateTabMeta();
  }
  setStatus('Print undone ‚Äî positions restored on "' + undoneName + '"', 'success');
}

// ========== EVENTS ==========
document.getElementById('newSheetName').addEventListener('keydown', e => { if (e.key==='Enter') createNewSheet(); if (e.key==='Escape' && !firstRunRequired) closeModal('newSheetModal'); });
document.querySelectorAll('.modal-overlay').forEach(el => el.addEventListener('click', function(e) {
  if (e.target !== this) return;
  if (this.id === 'dialogModal') { dialogResolve(_dialogMode === 'alert'); }
  else { closeModal(this.id); }
}));

// ========== INIT ==========
initTheme();
loadSheets();
loadSavedTexts();

if (!Object.keys(sheets).length) {
  firstRunRequired = true;
  switchTab('sheets');
  showNewSheetModal();
} else {
  switchTab('sheets');
  buildSheetCards();
  buildSheetDetail();
  buildAssignedTexts();
  renderSavedTexts();
  updateTabMeta();
}

</script>
</body>
</html>
